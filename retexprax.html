<script type="module">
        // ‚≠ê Imports explicites requis pour le mod√®le multimodal Gemma
        import { AutoProcessor, AutoModelForImageTextToText } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers@latest'; 

        pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js`;

        // ‚≠ê Constantes du mod√®le Gemma
        const MODEL_NAME = 'onnx-community/gemma-3n-E2B-it-ONNX';
        // Supprimer TASK = 'text-generation' car nous n'utilisons plus le pipeline

        const dom = {
            loadModelBtn: document.getElementById('load-model-btn'), modelStatus: document.getElementById('model-status'),
            progressContainer: document.getElementById('progress-container'), progressBar: document.getElementById('progress-bar'),
            modelConsoleContainer: document.getElementById('model-console-container'), modelConsoleOutput: document.getElementById('model-console-output'),
            modelLoaderSection: document.getElementById('model-loader-section'),
            analysisInterface: document.getElementById('analysis-interface'),
            planInput: document.getElementById('plan-input'), retexInput: document.getElementById('retex-input'),
            planLabel: document.getElementById('plan-label'), retexLabel: document.getElementById('retex-label'),
            planFileName: document.getElementById('plan-file-name'), retexFileName: document.getElementById('retex-file-name'),
            retexSelectorContainer: document.getElementById('retex-selector-container'),
            retexSelector: document.getElementById('retex-selector'),
            analyzeBtn: document.getElementById('analyze-btn'), analyzeBtnText: document.getElementById('analyze-btn-text'),
            analyzeSpinner: document.getElementById('analyze-spinner'), analysisOutput: document.getElementById('analysis-output'),
            analysisConsoleContainer: document.getElementById('analysis-console-container'), analysisConsoleOutput: document.getElementById('analysis-console-output'),
            analysisResult: document.getElementById('analysis-result'),
            newAnalysisBtn: document.getElementById('new-analysis-btn'),
            darkModeToggle: document.getElementById('darkModeToggle'),
        };

        // ‚≠ê Mise √† jour de l'√©tat pour stocker le processeur et le mod√®le
        let state = { processor: null, model: null, planFile: null, retexFile: null, retexData: null };
        
        function logTo(consoleElement, message, type = 'info') {
            const logLine = document.createElement('p');
            logLine.className = 'log-line';
            const time = new Date().toLocaleTimeString();
            logLine.textContent = `[${time}] ${message}`;
            if (type === 'error') logLine.classList.add('log-error');
            else if (type === 'success') logLine.classList.add('log-success');
            consoleElement.appendChild(logLine);
            consoleElement.scrollTop = consoleElement.scrollHeight;
        }
        
        function switchToAnalysisView() {
            dom.modelLoaderSection.style.display = 'none';
            dom.analysisInterface.style.display = 'block';
        }

        // ‚≠ê Nouvelle fonction de chargement utilisant AutoProcessor et AutoModel
        async function loadModel() {
            if (state.model) {
                switchToAnalysisView();
                return;
            }

            dom.loadModelBtn.disabled = true;
            dom.progressContainer.style.display = 'block';
            dom.modelConsoleContainer.style.display = 'block';
            dom.modelConsoleOutput.innerHTML = '';
            
            const progressCallback = (p) => {
                if (p.status === 'ready') {
                    dom.modelStatus.textContent = 'Le mod√®le est pr√™t ! Initialisation...';
                    return;
                }
                if (typeof p.progress === 'number') {
                    const percentage = p.progress.toFixed(2);
                    dom.progressBar.style.width = percentage + '%';
                    dom.progressBar.textContent = `${percentage}%`;
                }
                let statusText = `[${p.status}] ${p.file || ''}`;
                dom.modelStatus.textContent = `Statut : ${statusText}`;
                const progressLog = typeof p.progress === 'number' ? `(${p.progress.toFixed(1)}%)` : '';
                logTo(dom.modelConsoleOutput, `${statusText} ${progressLog}`);
            };

            try {
                logTo(dom.modelConsoleOutput, `‚ñ∂Ô∏è D√©marrage du t√©l√©chargement du mod√®le ${MODEL_NAME}...`);
                
                // 1. Charger le processeur (tokenizer)
                state.processor = await AutoProcessor.from_pretrained(MODEL_NAME, {
                    progress_callback: progressCallback
                });
                logTo(dom.modelConsoleOutput, '‚úÖ Processeur charg√©.', 'success');

                // 2. Charger le mod√®le (avec configuration dtypes ONNX pour le Web)
                state.model = await AutoModelForImageTextToText.from_pretrained(MODEL_NAME, {
                    progress_callback: progressCallback,
                    dtype: {
                        embed_tokens: "q8",
                        audio_encoder: "q8",
                        vision_encoder: "fp16",
                        decoder_model_merged: "q4",
                    },
                    device: "wasm", // ‚≠ê CORRECTION APPLIQU√âE ICI !
                });
                
                logTo(dom.modelConsoleOutput, '‚úÖ Mod√®le initialis√© avec succ√®s.', 'success');
                switchToAnalysisView();

            } catch (error) {
                logTo(dom.modelConsoleOutput, '‚ùå ERREUR CRITIQUE LORS DU CHARGEMENT', 'error');
                logTo(dom.modelConsoleOutput, `Message : ${error.message}`, 'error');
                dom.modelStatus.textContent = "Erreur de chargement. Consulter le journal.";
                dom.modelStatus.style.color = 'var(--danger-red)';
                dom.loadModelBtn.disabled = false;
            }
        }
        
        async function handleFileSelect(event) {
            const inputId = event.target.id;
            const file = event.target.files[0];
            if (!file) return;

            dom.retexSelectorContainer.style.display = 'none';
            state.retexData = null;

            if (inputId === 'plan-input') {
                state.planFile = file;
                dom.planFileName.textContent = file.name;
                dom.planLabel.classList.add('loaded');
            } else if (inputId === 'retex-input') {
                state.retexFile = file;
                dom.retexFileName.textContent = file.name;
                dom.retexLabel.classList.add('loaded');

                if (file.type === 'application/json') {
                    try {
                        const text = await file.text();
                        const data = JSON.parse(text);
                        if (Array.isArray(data)) {
                            state.retexData = data;
                            dom.retexSelector.innerHTML = '';
                            data.forEach((item, index) => {
                                const option = document.createElement('option');
                                option.value = index;
                                option.textContent = item.Type_d_operation || `Rapport #${index + 1}`;
                                dom.retexSelector.appendChild(option);
                            });
                            dom.retexSelectorContainer.style.display = 'block';
                        }
                    } catch (e) {
                        alert('Erreur: Le fichier JSON est malform√©.');
                        return;
                    }
                }
            }
            updateAnalyzeButtonState();
        }

        function updateAnalyzeButtonState() {
            // Mise √† jour pour v√©rifier state.model au lieu de state.pipe
            dom.analyzeBtn.disabled = !(state.model && state.planFile && state.retexFile);
        }

        function setAnalysisUIState(isAnalyzing) {
            dom.analyzeBtn.disabled = isAnalyzing;
            dom.analyzeSpinner.style.display = isAnalyzing ? 'block' : 'none';
            dom.analyzeBtnText.textContent = isAnalyzing ? "Analyse en cours..." : "Comparer les Documents";
        }

        function resetForNewAnalysis() {
            state.planFile = null;
            state.retexFile = null;
            state.retexData = null;
            dom.planInput.value = '';
            dom.retexInput.value = '';
            dom.planFileName.textContent = '';
            dom.retexFileName.textContent = '';
            dom.planLabel.classList.remove('loaded');
            dom.retexLabel.classList.remove('loaded');
            dom.retexSelectorContainer.style.display = 'none';
            dom.analysisResult.style.display = 'none';
            dom.analysisConsoleContainer.style.display = 'none';
            dom.newAnalysisBtn.style.display = 'none';
            dom.analyzeBtn.style.display = 'flex';
            updateAnalyzeButtonState();
        }

        function convertJsonObjectToText(retexObject) {
            let text = '';
            for (const [key, value] of Object.entries(retexObject)) {
                const formattedKey = key.replace(/_/g, ' ').charAt(0).toUpperCase() + key.slice(1).replace(/_/g, ' ');
                text += `${formattedKey}: ${value}\n`;
            }
            return text;
        }
        
        function cleanText(text) {
            // Remplace les sauts de ligne multiples/espaces par un seul espace
            return text.replace(/\s+/g, ' ').trim();
        }

        // ‚≠ê Adaptation de l'extraction de la r√©ponse pour le format Chat Template
        const extractResponse = (full_text) => {
            // Le mod√®le g√©n√®re le prompt + <|assistant|> + r√©ponse.
            // On veut seulement la r√©ponse (apr√®s la derni√®re occurrence de <|assistant|>).
            const parts = full_text.split('<|assistant|>');
            return parts.length > 1 ? parts.pop().trim() : full_text.trim();
        };

        // ‚≠ê Adaptation compl√®te de la fonction analyzeDocuments pour Gemma
        async function analyzeDocuments() {
            if (!state.model || !state.planFile || !state.retexFile) return;
            
            setAnalysisUIState(true);
            dom.analysisConsoleContainer.style.display = 'block';
            dom.analysisConsoleOutput.innerHTML = '';
            dom.analysisResult.style.display = 'none';
            
            const log = (message, type) => logTo(dom.analysisConsoleOutput, message, type);

            try {
                log('‚ñ∂Ô∏è D√©marrage de l\'analyse...');
                // ... (Extraction de planText et retexText comme avant)

                log('üìÑ Extraction du texte de l\'Ordre Initial...');
                const planChunks = await extractTextFromFile(state.planFile);
                if (planChunks.length === 0) throw new Error("Le document OI est vide.");
                log('‚úÖ OI trait√©.', 'success');

                let retexTextForAnalysis;
                if (state.retexData) {
                    const selectedIndex = dom.retexSelector.value;
                    const selectedRetexObject = state.retexData[selectedIndex];
                    retexTextForAnalysis = convertJsonObjectToText(selectedRetexObject);
                    log(`‚ÑπÔ∏è Analyse du RETEX choisi : "${selectedRetexObject.Type_d_operation}"`);
                } else {
                    log('üìÑ Extraction du texte du RETEX...');
                    const retexChunks = await extractTextFromFile(state.retexFile);
                    if (retexChunks.length === 0) throw new Error("Le document RETEX est vide.");
                    retexTextForAnalysis = retexChunks[0];
                    log('‚úÖ RETEX trait√©.', 'success');
                }

                const planText = cleanText(planChunks[0]);
                const retexText = cleanText(retexTextForAnalysis);
                log(`‚ÑπÔ∏è Segments utilis√©s (OI: ${planText.length} car., RETEX: ${retexText.length} car.).`);

                // Configuration de g√©n√©ration
                const generationConfig = { 
                    max_new_tokens: 1024, 
                    temperature: 0.1, 
                    repetition_penalty: 1.1,
                    do_sample: false, // Ajout√© pour la coh√©rence avec l'inf√©rence
                };
                let finalReport = "### Analyse Comparative de l'Op√©ration\n\n";
                
                // La fonction cr√©e le texte de l'instruction √† l'int√©rieur du bloc de message utilisateur.
                const createInstructionMessage = (task) => {
                    return task + "\n\nOI: \"" + planText + "\"\n\nRETEX: \"" + retexText + "\"";
                };

                const generateAndExtract = async (task, logMessage) => {
                    log(logMessage);

                    // 1. Pr√©paration du prompt pour le Chat Template
                    const instruction = createInstructionMessage(task);
                    const messages = [
                        { role: "user", content: instruction },
                    ];
                    
                    const prompt = state.processor.apply_chat_template(messages, {
                        add_generation_prompt: true, // Ajoute la balise <|assistant|>
                    });

                    // 2. Tokenisation (sans image ni audio, seulement le texte)
                    const inputs = await state.processor(prompt, null, null, {
                        add_special_tokens: false,
                    });

                    // 3. G√©n√©ration du texte
                    const outputs = await state.model.generate({
                        ...inputs,
                        ...generationConfig,
                    });

                    // 4. D√©codage et extraction de la r√©ponse
                    const decoded = state.processor.batch_decode(outputs, { skip_special_tokens: false }); // skip_special_tokens=false pour garder <|assistant|>
                    return extractResponse(decoded[0]);
                };


                finalReport += "#### 1. VALIDATION DES OBJECTIFS\n" + await generateAndExtract(
                    "Identifie les phases de l'op√©ration qui se sont d√©roul√©es conform√©ment √† l'OI. R√©ponds uniquement par une liste √† puces.", 
                    'üß† √âtape 1/3: Analyse de la conformit√© au plan...'
                ) + "\n\n";
                log('‚úîÔ∏è Conformit√© au plan analys√©e.', 'success');

                finalReport += "#### 2. √âCARTS TACTIQUES ET IMPR√âVUS\n" + await generateAndExtract(
                    "Identifie les √©carts tactiques, les impr√©vus et les menaces non anticip√©es rencontr√©s sur le terrain par rapport √† l'OI. R√©ponds uniquement par une liste √† puces.", 
                    'üß† √âtape 2/3: Analyse des √©carts tactiques...'
                ) + "\n\n";
                log('‚úîÔ∏è √âcarts analys√©s.', 'success');

                finalReport += "#### 3. RETOUR D'EXP√âRIENCE (REX)\n" + await generateAndExtract(
                    "Quels sont les enseignements (REX) et les recommandations concr√®tes pour am√©liorer les futurs modes op√©ratoires ? R√©ponds uniquement par une liste √† puces.", 
                    'üß† √âtape 3/3: G√©n√©ration du REX...'
                ) + "\n\n";
                log('‚úîÔ∏è Recommandations g√©n√©r√©es.', 'success');
                
                log('Rapport final assembl√©.', 'success');
                dom.analysisResult.innerHTML = marked.parse(finalReport);
                dom.analysisResult.style.display = 'block';
                dom.newAnalysisBtn.style.display = 'flex';
                dom.analyzeBtn.style.display = 'none';

            } catch (error) {
                log('‚ùå ERREUR CRITIQUE PENDANT L\'ANALYSE', 'error');
                log(`Erreur brute : ${error.message || JSON.stringify(error)}`, 'error');
            } finally {
                setAnalysisUIState(false);
            }
        }
        
        async function extractTextFromFile(file) {
            if (file.type === 'text/plain') {
                const text = await file.text();
                return text.split(/\n\s*\n/).filter(p => p.trim() !== '');
            }
            if (file.type === 'application/pdf') {
                const arrayBuffer = await file.arrayBuffer();
                const typedarray = new Uint8Array(arrayBuffer);
                const pdf = await pdfjsLib.getDocument(typedarray).promise;
                const chunks = [];
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(s => s.str).join(' ');
                    if (pageText.trim() !== '') {
                        chunks.push(pageText);
                    }
                }
                return chunks;
            }
            if (file.type === 'application/json') {
                 const text = await file.text();
                 return [text];
            }
            throw new Error(`Type de fichier non support√©: ${file.name}`);
        }

        dom.loadModelBtn.addEventListener('click', loadModel);
        dom.planInput.addEventListener('change', handleFileSelect);
        dom.retexInput.addEventListener('change', handleFileSelect);
        dom.analyzeBtn.addEventListener('click', analyzeDocuments);
        dom.newAnalysisBtn.addEventListener('click', resetForNewAnalysis);
        
        dom.darkModeToggle.addEventListener('click', () => {
            document.body.classList.toggle('light-mode'); document.body.classList.toggle('dark-mode');
            const isDarkMode = document.body.classList.contains('dark-mode');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
        });

        document.addEventListener('DOMContentLoaded', () => {
            if (localStorage.getItem('theme') === 'light') {
                document.body.classList.replace('dark-mode', 'light-mode');
                document.getElementById('darkModeIcon').textContent = 'clear_day';
            }
        });
    </script>
