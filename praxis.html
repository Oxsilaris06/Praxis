<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF--8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Praxis</title>
    <link rel="icon" href="favicon.ico" sizes="any" type="image/png">
    <link rel="icon" href="favicon.ico" type="image/svg+xml">
    <link rel="apple-touch-icon" href="favicon.ico">
    <link rel="manifest" href="site.webmanifest">
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Saira+Stencil+One&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0" />
    <style>
        :root {
            --bg-body: #121212; --bg-container: #1e1e1e; --bg-interactive: #2a2a2a;
            --text-primary: #e0e0e0; --text-secondary: #95a5a6; --border-color: #444444;
            --accent-blue: #5b9bd5; --accent-hover: #4a7aa5; --danger-red: #c0392b;
            --success-green: #27ae60;
        }
        body.light-mode {
            --bg-body: #f0f2f5; --bg-container: #ffffff; --bg-interactive: #f8f9fa;
            --text-primary: #212529; --text-secondary: #6c757d; --accent-blue: #0033a0;
            --border-color: #dee2e6;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html { font-size: 16px; }
        body { font-family: 'Oswald', sans-serif; background-color: var(--bg-body); color: var(--text-primary); line-height: 1.6; padding: 10px; padding-bottom: 90px; transition: background-color 0.3s, color 0.3s; }
        .container { width: 100%; max-width: 800px; margin: auto; background: var(--bg-container); padding: 20px; border-radius: 8px; border: 1px solid var(--border-color); }
        h1 { font-size: 2.2em; margin-bottom: 20px; color: var(--accent-blue); font-family: 'Saira Stencil One', sans-serif; text-align: center; letter-spacing: 1.5px; font-weight: 400; }
        h2 { font-size: 1.4em; color: var(--accent-blue); border-bottom: 2px solid var(--accent-blue); padding-bottom: 10px; margin-top: 20px; }
        h3 { font-size: 1.1em; color: var(--text-primary); margin-top: 15px; margin-bottom: 10px; }
        h4 { font-size: 1.0em; color: var(--text-secondary); margin-top: 10px; margin-bottom: 5px; }
        
        .wizard-progress { 
            display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; 
            margin-bottom: 25px; list-style-type: none; padding: 0; 
        }
        .wizard-progress-step {
            flex-grow: 1; padding: 8px 6px; text-align: center; font-size: 0.7em;
            color: var(--text-secondary); background-color: var(--bg-interactive);
            border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            min-width: 50px;
        }
        @media (min-width: 600px) {
             .wizard-progress-step {
                font-size: 0.85em;
                padding: 8px 12px;
             }
        }
        
        .wizard-progress-step:hover { background-color: var(--bg-body); }
        .wizard-progress-step.completed { border-color: var(--accent-blue); color: var(--accent-blue); }
        .wizard-progress-step.active {
            color: white; background-color: var(--accent-blue);
            border-color: var(--accent-blue); font-weight: 500;
        }
        .wizard-step { display: none; animation: fadeIn 0.5s; }
        .wizard-step.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .wizard-nav { display: flex; flex-wrap: wrap; justify-content: space-between; margin-top: 30px; border-top: 1px solid var(--border-color); padding-top: 20px; gap: 10px; }
        .wizard-nav-btn { flex-grow: 1; padding: 14px 20px; border: none; border-radius: 5px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 1.1em; min-height: 48px;}

        #prevBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        #nextBtn { background-color: var(--accent-blue); color: white; }
        #previewBtn { background-color: #6c757d; color: white; }
        #retexReportBtn { background-color: #008080; color: white; }
        label { display: block; margin-bottom: 5px; font-weight: bold; color: var(--text-secondary); }
        input, textarea, select { width: 100%; padding: 14px; margin-bottom: 15px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1.1rem; background-color: var(--bg-interactive); color: var(--text-primary); font-family: 'Oswald', sans-serif; min-height: 48px;}
        textarea { min-height: 120px; }
        
        .dynamic-list-item { 
            display: flex; flex-direction: column; align-items: stretch;
            gap: 10px; margin-bottom: 10px; 
        }
        
        .dynamic-list-item > *:not(button) { 
            flex-grow: 1; 
            margin-bottom: 0; 
            min-height: 48px; 
        }

        @media (min-width: 480px) {
            .wizard-step .dynamic-list-item:has(#date_naissance) {
                flex-direction: row;
            }
            .wizard-step .dynamic-list-item:has(#date_naissance) input {
                width: auto;
            }
        }
        
        button.add-btn, button.remove-btn { min-height: 44px; }
        
        button.add-btn { background-color: #27ae60; color: white; border: none; border-radius: 4px; padding: 8px 12px; margin-top: 5px; cursor: pointer; }
        button.remove-btn { background-color: var(--danger-red); color: white; border: none; border-radius: 4px; padding: 5px 10px; font-size: 14px; cursor: pointer; }
        
        .chip-container {
            display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px; padding: 5px 0;
            border-bottom: 1px dashed var(--border-color);
        }
        .chip-btn {
            background-color: var(--bg-interactive); color: var(--text-secondary); 
            border: 1px solid var(--border-color); padding: 8px 12px; border-radius: 20px;
            cursor: pointer; transition: all 0.2s; font-family: 'Oswald', sans-serif;
            font-size: 0.9em; flex-shrink: 0;
        }
        .chip-btn.selected {
            background-color: var(--accent-blue); color: white; border-color: var(--accent-blue);
        }
        .chip-btn:hover:not(.selected) {
            background-color: var(--bg-body);
        }

        .collapsible-container { background-color: var(--bg-interactive); border: 1px solid var(--border-color); border-radius: 5px; margin-bottom: 15px; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; cursor: pointer; padding: 15px; }
        .collapsible-header h3 { margin: 0; font-size: 1.2em; }
        .collapsible-header .material-symbols-outlined { transition: transform 0.3s; }
        .collapsible-container.open .collapsible-header .material-symbols-outlined { transform: rotate(180deg); }
        .collapsible-content { padding: 0 15px; max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out, padding 0.3s ease-out; }
        .collapsible-container.open .collapsible-content { max-height: 4000px; padding-top: 10px; padding-bottom: 15px; }
        
        .articulation-composition-display p { margin-bottom: 5px; }
        .articulation-composition-display strong { color: var(--accent-blue); }

        .dock-menu { 
            position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
            display: flex; gap: 10px; padding: 10px; z-index: 1000; 
            background-color: rgba(30, 30, 30, 0.7); 
            border: 1px solid var(--border-color); 
            border-radius: 35px; backdrop-filter: blur(10px); 
            transition: all 0.3s ease-in-out; 
        }
        .dock-menu-item { 
            display: flex; align-items: center; justify-content: center; 
            background-color: var(--bg-container); color: var(--text-primary); 
            border: 1px solid var(--border-color); 
            border-radius: 50%; width: 50px; height: 50px; 
            font-size: 28px; cursor: pointer; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            transition: all 0.2s; text-decoration: none; flex-shrink: 0; 
        }
        .dock-menu-item:hover { transform: scale(1.1); }
        .dock-menu.collapsed { 
            width: 55px; height: 55px; padding: 5px; 
            border-radius: 50%; border: none; 
            background-color: transparent; 
        }
        .dock-menu.collapsed .dock-menu-item:not(#dockToggleBtn) { 
            opacity: 0; width: 0; margin-left: -10px; visibility: hidden; 
        }
        #dockToggleBtn .material-symbols-outlined { transition: transform 0.3s ease; }
        .dock-menu.collapsed #dockToggleBtn .material-symbols-outlined { transform: rotate(180deg); }

        .photo-input, #sessionFileInput, #jsonConfigInput { display: none; }
        .file-upload-label { background-color: var(--accent-blue); color: white !important; padding: 10px 14px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; font-family: 'Oswald', sans-serif; font-weight: normal; display: inline-block; text-align: center; flex-shrink: 0; }
        .file-upload-label:hover { background-color: var(--accent-hover); }
        .file-name-display { color: var(--text-secondary); font-style: italic; margin-left: 8px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; }
        .image-preview { max-width: 150px; max-height: 100px; margin-top: 10px; border-radius: 4px; border: 1px solid var(--border-color); }
        .image-preview-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .image-preview-item .remove-btn, .image-preview-item .add-btn {
            font-size: 0.8em; padding: 2px 6px; min-height: unset;
        }
        .photo-display-area {
            display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; min-height: 70px;
            border: 1px dashed var(--border-color); border-radius: 5px; align-content: flex-start;
        }
        .photo-display-area .image-preview {
            margin: 0;
        }

        .draggable { cursor: grab; user-select: none; }
        .draggable.dragging { opacity: 0.5; cursor: grabbing; }
        
        #patracdvr_container, #unassigned_members_container { 
            display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; min-height: 70px; 
            border: 1px dashed var(--border-color); border-radius: 5px; align-content: flex-start;
        }
        
        .patracdvr-members-container, #unassigned_members_container {
            transition: border-color 0.2s;
        }

        .patracdvr-member-btn { 
            background-color: var(--bg-body); border: 2px solid var(--border-color); color: var(--text-primary); 
            padding: 8px 12px; border-radius: 5px; text-align: center; font-family: 'Oswald', sans-serif; 
            cursor: pointer; transition: all 0.2s; min-height: 56px; display: flex; flex-direction: column; justify-content: center;
        }
        .patracdvr-member-btn:hover { border-color: var(--accent-hover); }
        .patracdvr-member-btn.member-active { border-color: var(--accent-blue); box-shadow: 0 0 8px var(--accent-blue); }
        .patracdvr-member-btn .trigramme { font-weight: bold; }
        .patracdvr-member-btn .fonction { font-size: 0.8em; color: var(--text-secondary); display: block; }
        
        .patracdvr-vehicle-row {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px;
            padding-top: 28px; 
            border: 1px solid var(--border-color);
            background-color: var(--bg-body);
            border-radius: 5px;
            min-height: 56px; 
            min-width: 100px; 
            width: auto; 
            align-items: flex-start;
            justify-content: flex-start;
        }
        .patracdvr-vehicle-row .patracdvr-members-container {
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            min-height: 40px;
            width: 100%;
            padding: 5px;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            align-content: flex-start;
        }
        .vehicle-header {
            position: absolute;
            top: 4px;
            left: 8px;
            right: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .vehicle-name {
            font-size: 0.9em;
            font-weight: bold;
            color: var(--accent-blue);
        }
        .vehicle-header .remove-btn {
            padding: 2px 5px;
            min-height: unset;
            font-size: 12px;
        }
        #vehicle_creation_buttons { display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px; margin-bottom: 20px; padding: 10px; border: 1px dashed var(--border-color); border-radius: 5px; }
        .add-vehicle-btn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        
        #editMemberModal, #quickEditModal, #settingsModal { color: var(--text-primary); background: var(--bg-container); width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; margin: 0; border: none; border-radius: 0; padding: 15px; }
        #editMemberModal::backdrop, #quickEditModal::backdrop, #settingsModal::backdrop { background: rgba(0, 0, 0, 0.85); }
        #editMemberModal #editMemberForm, #quickEditModal .modal-form, #settingsModal .modal-form { display: flex; flex-direction: column; height: 100%; }
        #editMemberModal .modal-content, #quickEditModal .modal-content, #settingsModal .modal-content { flex: 1 1 auto; overflow-y: auto; padding: 0 5px; }
        #editMemberModal .modal-actions, #quickEditModal .modal-actions, #settingsModal .modal-actions { flex-shrink: 0; display: flex; justify-content: space-between; gap: 10px; margin-top: 20px; }
        #editMemberModal .modal-actions button, #quickEditModal .modal-actions button, #settingsModal .modal-actions button { flex: 1; }
        #modal_cancelBtn, #quick_modal_closeBtn, #settings_closeBtn { background-color: var(--bg-interactive); color: var(--text-primary); border: 1px solid var(--border-color); }
        #modal_deleteBtn { background-color: var(--danger-red); color: white; }
        #settings_saveBtn { background-color: var(--success-green); color: white; }

        #quickEditPanel { display: none; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px; margin-top: 20px; background-color: var(--bg-body); }
        #quickEditPanel h4 { margin-top: 0; }
        #quickEditPanel h4 #selectedMemberTrigramme { color: var(--accent-blue); }
        .quick-edit-content .quick-edit-tab-panel { display: none; }
        .quick-edit-options { display: flex; flex-wrap: wrap; gap: 8px; }
        .quick-edit-btn { background-color: var(--bg-interactive); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 6px 10px; border-radius: 4px; cursor: pointer; font-family: 'Oswald', sans-serif; font-size: 0.9em; transition: all 0.2s; }
        .quick-edit-btn:hover { border-color: var(--accent-hover); color: var(--text-primary); }
        .quick-edit-btn.selected { background-color: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        #quickEditModal .quick-edit-category { margin-bottom: 20px; }
        #quickEditModal .quick-edit-category h5 { font-size: 1.1em; color: var(--text-secondary); margin-bottom: 10px; border-bottom: 1px solid var(--border-color); padding-bottom: 5px; }

        #annotationModal { width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh; background: var(--bg-container); color: var(--text-primary); border: none; border-radius: 0; padding: 0; overflow: hidden; }
        #annotationModal::backdrop { background: rgba(0,0,0,0.85); }
        .annotation-wrapper { display: flex; flex-direction: column; height: 100%; }
        .annotation-toolbar { order: 2; display: flex; flex-direction: column; gap: 10px; padding: 10px; background: var(--bg-body); border-top: 1px solid var(--border-color); flex-shrink: 0; }
        .toolbar-main-tools, .toolbar-contextual-tools { 
            display: flex; 
            flex-wrap: nowrap; 
            gap: 10px; 
            overflow-x: auto; 
            padding-bottom: 5px; 
        }
        .toolbar-main-tools::-webkit-scrollbar, .toolbar-contextual-tools::-webkit-scrollbar { height: 4px; }
        .toolbar-main-tools::-webkit-scrollbar-thumb, .toolbar-contextual-tools::-webkit-scrollbar-thumb { background: var(--border-color); }
        .tool-btn { 
            padding: 10px; font-family: 'Oswald', sans-serif; border: 1px solid var(--border-color); 
            background: var(--bg-interactive); color: var(--text-primary); cursor: pointer; border-radius: 4px; 
            display: flex; align-items: center; justify-content: center; flex-direction: column; gap: 4px; 
            flex-shrink: 0; min-width: 80px; 
        }
        .tool-btn .material-symbols-outlined { font-size: 28px; }
        .tool-btn.active { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }
        .tool-controls, #contextual_tools { display: none; }
        .tool-controls.active, #contextual_tools.active { 
            display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 10px; 
            border: 1px dashed var(--border-color); border-radius: 4px; 
            overflow-x: auto;
            max-width: 100%;
        }
        .tool-controls label { margin-bottom: 0; }
        .tool-controls input { margin-bottom: 0; padding: 8px; max-width: 150px; } 
        #edit_text_btn { display: none; }
        #contextual_tools.active.location-selected #edit_text_btn { display: flex; }
        .annotation-actions { display: flex; justify-content: space-around; gap: 10px; padding-top: 10px; border-top: 1px solid var(--border-color); margin-top: 10px;}
        .annotation-actions button { flex: 1; justify-content: center; }
        .annotation-canvas-container { order: 1; flex-grow: 1; display: flex; align-items: center; justify-content: center; background: #000; padding: 5px; overflow: auto; min-height: 0; }
        #annotationCanvas { max-width: 100%; max-height: 100%; object-fit: contain; }
        .retex-section {
            display: flex; flex-direction: column;
            border: 1px solid var(--border-color); padding: 15px; border-radius: 5px;
            margin-top: 20px;
        }
        .retex-actions {
            display: flex; gap: 10px; margin-top: 15px;
        }
        .retex-status {
            margin-top: 10px; font-style: italic; color: var(--text-secondary);
        }
        .retex-output-content {
            border: 1px dashed var(--border-color); padding: 15px; border-radius: 5px;
            margin-top: 20px; min-height: 200px;
            white-space: pre-wrap;
            font-family: monospace;
            overflow-x: auto;
        }
        .retex-output-content h3 { color: var(--accent-blue); }
        
        .retex-output-content h4 { color: var(--accent-blue); border-bottom: 1px solid var(--border-color); margin-top: 10px; }
        .retex-output-content ul { list-style-type: disc; padding-left: 20px; }
        .retex-output-content p, .retex-output-content li { margin-bottom: 5px; }

         #presentationModal {
            width: 95vw; max-width: 1200px; height: 95vh; 
            background: var(--bg-body); color: var(--text-primary); 
            border: 1px solid var(--accent-blue); border-radius: 8px; 
            padding: 20px; overflow: hidden;
        }
        #presentationModal::backdrop { background: rgba(0, 0, 0, 0.85); }

        #presentation-content {
            height: calc(100% - 60px); 
            overflow-y: auto; 
            padding-right: 15px; 
        }
        #presentation-content h2 { 
            color: var(--accent-blue); 
            font-size: 1.8em; 
            border-bottom: 2px solid var(--accent-blue); 
            padding-bottom: 5px; 
        }
        #presentation-content h3 { 
            color: var(--accent-blue); 
            font-size: 1.3em; 
            margin-top: 15px; 
            margin-bottom: 10px; 
        }
        #presentation-content p {
            margin-bottom: 8px;
            padding-left: 15px;
        }
        #presentation-content strong {
             color: var(--danger-red);
        }
        #presentation-content table {
             width: 100%; border-collapse: collapse; margin-top: 15px; margin-bottom: 20px;
        }
        #presentation-content th {
             background-color: var(--accent-blue); color: white; padding: 10px; border: 1px solid var(--text-primary); text-align: left;
        }
        #presentation-content td {
             padding: 10px; border: 1px solid var(--text-secondary); vertical-align: top;
             background-color: var(--bg-interactive);
        }
        #presentation-content img {
            max-width: 100%; height: auto; border-radius: 4px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
        }
        #presentation-content .image-container {
             text-align: center; margin: 20px 0; border: 1px solid var(--accent-blue); 
             padding: 10px; background-color: var(--bg-container);
        }
        .modal-actions-pdf {
            display: flex; justify-content: flex-end; gap: 10px; margin-top: 20px; 
            flex-shrink: 0;
        }
        .modal-actions-pdf button { width: auto; }
        .modal-actions-pdf #downloadPdfBtn { flex: 1; max-width: 250px; background-color: var(--success-green); }

        .coherence-alert {
            background-color: #331f1f;
            color: #c0392b;
            border: 1px solid #c0392b;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: bold;
            display: flex;
            align-items: center;
        }
        .coherence-alert .material-symbols-outlined {
            margin-right: 10px;
            font-size: 24px;
        }

        @media (min-width: 768px) {
            body { padding: 15px; padding-bottom: 80px; }
            .dynamic-list-item { flex-direction: row; }
            #editMemberModal, #quickEditModal, #settingsModal { width: 90%; max-width: 500px; height: auto; max-height: 90vh; margin: auto; border: 1px solid var(--border-color); border-radius: 8px; }
            #quickEditPanel { display: block; }
            .wizard-nav { flex-wrap: nowrap; }
            .wizard-nav-btn { width: auto; margin-top: 0; }
            #annotationModal { width: 95vw; max-width: 1400px; height: 95vh; border: 1px solid var(--border-color); border-radius: 8px;}
            .annotation-wrapper { flex-direction: row; }
            .annotation-toolbar { order: 1; flex-direction: column; width: 250px; border-top: none; border-right: 1px solid var(--border-color); }
            .toolbar-main-tools, .toolbar-contextual-tools { flex-direction: column; overflow-x: hidden; }
            .tool-btn { flex-direction: row; justify-content: flex-start; min-width: unset; }
            .tool-controls.active, #contextual_tools.active { 
                 overflow-x: hidden;
                 max-width: none;
            }
            .annotation-actions { flex-direction: column; margin-top: auto; padding-top: 20px; }
            .annotation-actions button { justify-content: flex-start; }
            .annotation-canvas-container { order: 2; padding: 10px; }
            
            .quick-edit-tabs { display: none; } 
            .quick-edit-content .quick-edit-tab-panel.active { display: block !important; } 
            .quick-edit-content { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
            .quick-edit-content h5 { font-size: 0.9em; color: var(--text-secondary); margin-bottom: 8px; text-transform: uppercase; }
        }

        .tutorial-popup { position: absolute; background: var(--bg-container); color: var(--text-primary); border: 1px solid var(--accent-blue); border-radius: 8px; padding: 15px; box-shadow: 0 4px 12px rgba(0,0,0,0.35); z-index: 1001; width: 300px; display: none; flex-direction: column; gap: 10px; }
        .tutorial-popup p { margin-bottom: 0; }
        .tutorial-popup button { background-color: var(--accent-blue); color: white; border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer; font-family: 'Oswald', sans-serif; text-transform: uppercase; }
        .tutorial-popup .close-btn { position: absolute; top: 5px; right: 10px; font-size: 20px; cursor: pointer; color: var(--text-secondary); }
        .highlight-element { box-shadow: 0 0 0 5px var(--accent-blue) !important; transition: box-shadow 0.3s ease-in-out; position: relative; z-index: 1002; }

        @media (max-width: 600px) {
            .dock-menu:not(.collapsed) {
                width: 95%;
                padding: 5px;
                gap: 5px;
                justify-content: center;
                display: flex; 
                flex-wrap: wrap; 
            }
            .dock-menu:not(.collapsed) .dock-menu-item {
                width: 45px;
                height: 45px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body class="dark-mode">

    <dialog id="presentationModal">
        <div id="presentation-content">
            </div>
        <div class="modal-actions-pdf">
            <button id="downloadPdfBtn" type="button" class="wizard-nav-btn">
                Télécharger le PDF 📄
            </button>
            <button id="closePresentationModalBtn" type="button" class="wizard-nav-btn" style="background-color: var(--danger-red); color: white;">
                Fermer
            </button>
        </div>
    </dialog>
    <div class="dock-menu" id="dockMenu">
        <div class="dock-menu-item" id="dockToggleBtn" title="Réduire"><span class="material-symbols-outlined">expand_more</span></div>
        <a href="index.html" class="dock-menu-item" title="Accueil"><span class="material-symbols-outlined">home</span></a>
        <div class="dock-menu-item" id="importSessionBtn" title="Importer une session"><span class="material-symbols-outlined">file_upload</span></div>
        <div class="dock-menu-item" id="exportSessionBtn" title="Exporter la session"><span class="material-symbols-outlined">file_download</span></div>
        <div class="dock-menu-item" id="settingsBtn" title="Paramètres"><span class="material-symbols-outlined">settings</span></div>
        <div class="dock-menu-item" id="darkModeToggle" title="Changer le thème"><span class="material-symbols-outlined" id="darkModeIcon">nightlight</span></div>
        <div class="dock-menu-item" id="resetBtn" title="Réinitialiser le formulaire"><span class="material-symbols-outlined">refresh</span></div>
        <div class="dock-menu-item" id="tutorialBtn" title="Lancer le tutoriel"><span class="material-symbols-outlined">school</span></div>
    </div>
    <input type="file" id="sessionFileInput" accept=".json" />
    <input type="file" id="jsonConfigInput" accept=".json"/> 
    <dialog id="settingsModal">
        <div class="modal-form">
            <h3>Paramètres de l'application</h3>
            <div class="modal-content">
                <h4>Clé API Google Gemini</h4>
                <p>Pour l'analyse des rapports RETEX, vous devez fournir une clé API personnelle de Google Gemini. L'analyse est effectuée directement depuis votre navigateur.</p>
                <label for="geminiApiKey">Clé API:</label>
                <input type="password" id="geminiApiKey" placeholder="Saisissez votre clé d'API">
                <p style="margin-top: 15px;">**Note Importante:** Après la sauvegarde, votre clé sera stockée **uniquement dans votre navigateur** pour des raisons de sécurité et de confidentialité.</p>
            </div>
            <div class="modal-actions">
                <button type="button" id="settings_closeBtn">Fermer</button>
                <button type="button" id="settings_saveBtn">Sauvegarder</button>
            </div>
        </div>
    </dialog>

    <div id="tutorial-popup" class="tutorial-popup">
        <span class="close-btn">&times;</span>
        <p id="popup-text"></p>
        <button id="next-popup-btn">Suivant</button>
    </div>

    <dialog id="editMemberModal">
        <form id="editMemberForm" onsubmit="return false;">
            <h3>Éditer le membre</h3>
            <div class="modal-content">
                <label for="modal_trigramme">Trigramme:</label>
                <input type="text" id="modal_trigramme" placeholder="Trigramme">
                <label for="modal_fonction">Fonction:</label>
                <select id="modal_fonction"></select>
                <label for="modal_cellule">Cellule:</label>
                <select id="modal_cellule"></select>
                <label for="modal_armement">Armement:</label>
                <select id="modal_armement"></select>
                <label for="modal_equipement">Équipement 1:</label>
                <select id="modal_equipement"></select>
                <label for="modal_equipement2">Équipement 2:</label>
                <select id="modal_equipement2"></select>
                <label for="modal_tenue">Tenue:</label>
                <select id="modal_tenue"></select>
                <label for="modal_gpb">GPB:</label>
                <select id="modal_gpb"></select>
            </div>
            <div class="modal-actions">
                <button type="button" id="modal_deleteBtn" class="remove-btn">Renvoyer en Attente</button>
                <button type="button" id="modal_cancelBtn">Annuler</button>
                <button type="submit" id="modal_saveBtn" class="add-btn">Sauvegarder</button>
            </div>
        </form>
    </dialog>
    
    <dialog id="quickEditModal">
        <div class="modal-form">
            <h3 id="quick_modal_title">Édition rapide</h3>
            <div id="quick_modal_content" class="modal-content"></div>
            <div class="modal-actions">
                <button type="button" id="quick_modal_closeBtn">Fermer</button>
            </div>
        </div>
    </dialog>

    <dialog id="annotationModal">
        <div class="annotation-wrapper">
            <div class="annotation-toolbar">
                 <div id="contextual_tools">
                     <div class="toolbar-contextual-tools">
                        <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                            <label for="rotation_input" style="font-size: 0.8em; margin:0;">Rotation (Degrés)</label>
                            <input type="number" id="rotation_input" min="0" max="360" step="1" value="0" style="max-width: 80px; text-align: center; padding: 5px; height: 35px; margin: 0;" onchange="updateAnnotationRotation()">
                        </div>
                        <button id="edit_text_btn" class="tool-btn"><span class="material-symbols-outlined">edit</span>Texte</button>
                         <button id="delete_btn" class="tool-btn" style="background-color: var(--danger-red); color: white;"><span class="material-symbols-outlined">delete</span>Supprimer</button>
                     </div>
                 </div>
                 <div class="toolbar-main-tools">
                     <button id="tool_move" class="tool-btn active"><span class="material-symbols-outlined">open_with</span>Déplacer</button>
                     <button id="tool_location" class="tool-btn"><span class="material-symbols-outlined">place</span>Emplacement</button>
                     <button id="tool_arrow" class="tool-btn"><span class="material-symbols-outlined">arrow_right_alt</span>Désigner</button>
                     <button id="tool_box" class="tool-btn"><span class="material-symbols-outlined">crop_square</span>Encadrer</button>
                 </div>
                 <div id="controls_location" class="tool-controls">
                     <label for="circle_text">Texte:</label>
                     <input type="text" id="circle_text" value="Zone">
                     <label for="circle_opacity">Transparence:</label>
                     <input type="range" id="circle_opacity" min="0.1" max="1" step="0.1" value="0.5">
                 </div>
                 <div id="controls_arrow" class="tool-controls">
                     <label for="arrow_thickness">Épaisseur:</label>
                     <input type="range" id="arrow_thickness" min="1" max="25" step="1" value="5">
                 </div>
                 <div id="controls_box" class="tool-controls">
                     <label for="box_thickness">Épaisseur:</label>
                     <input type="range" id="box_thickness" min="1" max="20" step="1" value="5">
                 </div>
                 <div class="annotation-actions">
                     <button id="tool_reset" class="tool-btn"><span class="material-symbols-outlined">delete_sweep</span>Effacer tout</button>
                     <button id="annotation_cancel" class="tool-btn">Annuler</button>
                     <button id="annotation_save" class="tool-btn" style="background-color: #27ae60; color: white;"><span class="material-symbols-outlined">save</span>Sauvegarder</button>
                 </div>
            </div>
            <div class="annotation-canvas-container">
                <canvas id="annotationCanvas"></canvas>
            </div>
        </div>
    </dialog>

    <div class="container">
        <h1>Générateur d'OI</h1>
        
        <ul class="wizard-progress">
            <li class="wizard-progress-step" onclick="goToStep(0)">1. Situation</li>
            <li class="wizard-progress-step" onclick="goToStep(1)">2. Adversaire</li>
            <li class="wizard-progress-step" onclick="goToStep(2)">3. Environnement</li>
            <li class="wizard-progress-step" onclick="goToStep(3)">4. Mission</li>
            <li class="wizard-progress-step" onclick="goToStep(4)">5. Exécution</li>
            <li class="wizard-progress-step" onclick="goToStep(5)">6. Articulation</li>
            <li class="wizard-progress-step" onclick="goToStep(6)">7. PATRACDVR</li>
            <li class="wizard-progress-step" onclick="goToStep(7)">8. Photos</li>
            <li class="wizard-progress-step" onclick="goToStep(8)">9. CAT</li>
            <li class="wizard-progress-step" onclick="goToStep(9)">10. Finalisation</li>
        </ul>

        <form id="oi-form">
            <div class="wizard-content">
                <div class="wizard-step">
                    <h2>1. Situation</h2>
                    <label for="date_op">Date de l'opération:</label><input type="date" id="date_op">
                    <label for="situation_generale">1.1 Générale:</label><textarea id="situation_generale"></textarea>
                    <label for="situation_particuliere">1.2 Particulière:</label><textarea id="situation_particuliere"></textarea>
                </div>

                <div class="wizard-step">
                    <h2>2. Adversaire</h2>
                    <label>Photo principale de l'adversaire (Aperçu):</label>
                    <div id="adversary_photo_display" class="photo-display-area"></div>
                    <label for="nom_adversaire">Nom/Prénom:</label><input type="text" id="nom_adversaire">
                    <label for="domicile_adversaire">Domicile:</label><textarea id="domicile_adversaire" rows="2"></textarea>
                    <label>Moyens Employés (ME):</label><div id="me_container"></div><button type="button" class="add-btn" onclick="addMeField()">➕ ME</button>
                    <h3>Informations TO</h3>
                    <h4>Date et lieu de naissance:</h4>
                    <div class="dynamic-list-item"><input type="date" id="date_naissance"><input type="text" id="lieu_naissance" placeholder="Lieu de naissance"></div>
                    <div class="dynamic-list-item"><input type="text" id="stature_adversaire" placeholder="Stature"><select id="ethnie_adversaire"><option>Caucasien</option><option>Nord africain</option><option>Afro-antillais</option><option>Asiatique</option></select></div>
                    <label for="signes_particuliers">Signes particuliers:</label><input type="text" id="signes_particuliers">
                    <label for="profession_adversaire">Profession:</label><input type="text" id="profession_adversaire">
                    <label for="antecedents_adversaire">Antécédents:</label><textarea id="antecedents_adversaire" rows="2"></textarea>
                    
                    <label>État d'esprit:</label>
                    <div id="etat_esprit_container" class="chip-container" data-options='["Serein", "Hostile", "Conciliant", "Sur ses gardes"]'></div>
                    <label for="attitude_adversaire">Attitude (connue):</label><textarea id="attitude_adversaire" rows="2"></textarea>
                    
                    <label>Volume (renfort potentiel):</label>
                    <div id="volume_adversaire_container" class="chip-container" data-options='["Seul", "Famille", "BO", "Conjointe", "2-3", "4+"]'></div>
                    
					<h3>Photos des renforts potentiels (Aperçu)</h3>
                    <div id="renforts_photo_display" class="photo-display-area"></div>
                    
                    <h3 style="margin-top: 20px;">Photos supplémentaires de l'adversaire (Aperçu)</h3>
                    <div id="adversary_extra_photos_display" class="photo-display-area"></div>
					
                    <label for="substances_adversaire">Substances:</label><input type="text" id="substances_adversaire">
                    <label>Véhicules:</label><div id="vehicules_container"></div><button type="button" class="add-btn" onclick="addDynamicField('vehicules_container')">➕</button>
                    <label for="armes_connues">Armes connues:</label><input type="text" id="armes_connues">
                </div>
                
                <div class="wizard-step">
                    <h2>3. Environnement</h2>
                     <label>Ami(e)s (Unités en soutien):</label><input type="text" id="amies">
                     <label>Terrain / Météo:</label><input type="text" id="terrain_info">
                     <label>Population:</label><input type="text" id="population">
                     <label for="cadre_juridique">Cadre juridique:</label><input type="text" id="cadre_juridique">
                </div>

                <div class="wizard-step">
                    <h2>4. Mission du PSIG</h2>
                    <textarea id="missions_psig" rows="8">

INTERPELLER L'OBJECTIF.

ASSISTER LORS DE LA PERQUISITION.

CONDUITE AU LIEU DE GAV.</textarea>
                </div>

                <div class="wizard-step">
                     <h2>5. Exécution</h2>
                     <label for="date_execution">Date d'exécution:</label><input type="date" id="date_execution">
                     <label for="heure_execution">Heure d'exécution (H):</label><input type="time" id="heure_execution" value="06:00">
                     <label for="type_action">Type d'action:</label><input type="text" id="type_action">
                     <h3>Chronologie</h3><div id="time_events_container"></div><button type="button" class="add-btn" onclick="addTimeEvent()">➕</button>
                     <h3>Hypothèses</h3>
                     <label for="hypothese_h1">H1:</label><input type="text" id="hypothese_h1" value="Target présente LE1">
                     <label for="hypothese_h2">H2:</label><input type="text" id="hypothese_h2" value="Target présente LE2">
                     <label for="hypothese_h3">H3:</label><input type="text" id="hypothese_h3" value="Target absente LE 1 et 2">
                </div>

                <div class="wizard-step">
                     <h2>6. Articulation (MOIPC/ZMSPCP)</h2>
                     <label for="place_chef">Place du Chef (Générale):</label><input type="text" id="place_chef">
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe INDIA (INTER)</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                                 <label for="india_mission">Mission:</label><textarea id="india_mission" rows="3">RECONNAÎTRE LE DOMICILE EN VUE D'APPRÉHENDER L'OBJECTIF</textarea>
                                 
                                 <h3>Composition</h3>
                                 <div id="india_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="india_objectif">Objectif:</label><input type="text" id="india_objectif">
                                 <label for="india_itineraire">Itinéraire:</label><textarea id="india_itineraire" rows="3"></textarea>
                                 
                                 <h3>Photos - Itinéraire (Aperçu)</h3>
                                 <h4>Itinéraire Extérieur</h4>
                                 <div id="photo_container_itineraire_exterieur_display" class="photo-display-area"></div>
                                 <h4>Itinéraire Intérieur</h4>
                                 <div id="photo_container_itineraire_interieur_display" class="photo-display-area"></div>

                                 <label for="india_points_particuliers">Points Particuliers:</label><textarea id="india_points_particuliers" rows="3"></textarea>
                                 <label for="india_cat">Conduite à Tenir:</label><textarea id="india_cat" rows="6">- Si décelé, dynamiser jusqu'au domicile.
- Si présence tierce personne lors de la progression, contrôler.
- Si fuite, CR direction fuite + interpellation.
- Si rébellion, usage du strict niveau de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                          </div>
                     </div>
                     <div class="collapsible-container">
                          <div class="collapsible-header"><h3>Équipe Appui/Observation (AO) - ZMSPCP</h3><span class="material-symbols-outlined">expand_more</span></div>
                          <div class="collapsible-content">
                             
                                 <h3>Composition</h3>
                                 <div id="ao_composition_display" class="articulation-composition-display">
                                     <p><i>La composition sera affichée ici après configuration dans l'onglet PATRACDVR.</i></p>
                                 </div>

                                 <label for="ao_zone_installation">Zone d'installation (Z):</label><textarea id="ao_zone_installation" rows="3"></textarea>
                                 <h3>Photos - Zone d'installation (Aperçu)</h3>
                                 <h4>Baptême terrain</h4>
                                 <div id="photo_container_bapteme_terrain_display" class="photo-display-area"></div>
                                 <h4>Emplacement AO</h4>
                                 <div id="photo_container_emplacement_ao_display" class="photo-display-area"></div>

                                 <label for="ao_mission">Mission (M):</label><textarea id="ao_mission" rows="3">BOUCLER - SURVEILLER - INTERDIRE TOUTE FUITE</textarea>
                                 <label for="ao_secteur_surveillance">Secteur de surveillance (S):</label><textarea id="ao_secteur_surveillance" rows="3"></textarea>
                                 <label for="ao_points_particuliers">Points Particuliers (P):</label><textarea id="ao_points_particuliers" rows="3"></textarea>
                                 <label for="ao_cat">Conduite à Tenir (C):</label><textarea id="ao_cat" rows="6">- Compte rendu de mise en place.
- Renseigner régulièrement.
- Si décelé, CR.
- Si fuite, CR direction fuite + interpellation si rapport de force favorable.
- Si rébellion, usage du strict minimum de force nécessaire.
- Si retranchement, CR + réarticulation pour fixer l'adversaire.</textarea>
                                 <label for="ao_place_chef">Place du Chef (P):</label><input type="text" id="ao_place_chef">
                          </div>
                     </div>
                </div>
                
                <div class="wizard-step">
                    <h2>7. PATRACDVR</h2>
                    <div style="margin-bottom: 20px; padding: 15px; border: 1px solid var(--border-color); border-radius: 5px;">
                        
                        <div style="display: flex; flex-wrap: wrap; justify-content: space-between; gap: 10px;">
                            <button type="button" id="importDefaultConfigBtn" class="add-btn" style="background-color: var(--accent-blue); flex-grow: 1;">Charger Config par Défaut ⚙️</button>
                            <button type="button" id="importJsonConfigBtn" class="add-btn" style="background-color: var(--success-green); flex-grow: 1;">Importer Configuration Membres (.json) 📤</button>
                            <button type="button" id="resetPatracdvrBtn" class="remove-btn" style="flex-grow: 1;">Réinitialiser PATRACDVR</button>
                        </div>
                    </div>

                    <div id="quickEditPanel">
                        <h4>Membre: <span id="selectedMemberTrigramme">Aucun</span>
                            <button type="button" id="fullEditBtn" class="add-btn" style="font-size: 0.8em; padding: 5px 8px; margin-left: 15px;">Édition Complète</button>
                        </h4>
                        <div class="quick-edit-content"></div>
                    </div>

                    <h4 style="margin-top: 20px;">Ajouter un véhicule ou un membre</h4>
                    <div id="vehicle_creation_buttons">
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualVehicleBtn">➕ Véhicule Manuel</button>
                        <button type="button" class="add-btn add-vehicle-btn" id="addManualMemberBtn">➕ Membre Manuel</button>
                        </div>

                    <h4 style="margin-top: 20px;">Composition des véhicules</h4>
                    <div id="patracdvr_container"></div>
                    
                    <h4 style="margin-top: 20px;">Personnel à attribuer</h4>
                    <div id="unassigned_members_container"></div>
                </div>

                <div class="wizard-step">
                    <h2>8. Gestion des Photos</h2>
                    <p>Utilisez cette section pour ajouter et annoter toutes les photos. Les aperçus s'afficheront dans les onglets correspondants.</p>
                
                    <div class="collapsible-container open">
                        <div class="collapsible-header">
                            <h3>Adversaire</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                            <div class="photo-upload-section">
                                <h4>Photo Principale</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_photo_input').click()">➕ Ajouter / Remplacer Photo</button>
                                <input type="file" id="adversary_photo_input" class="photo-input" accept="image/jpeg, image/png" onchange="handleFileChange(this, 'adversary_photo_preview_container', true)">
                                <div id="adversary_photo_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Photos Supplémentaires</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('adversary_extra_photos_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="adversary_extra_photos_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'adversary_extra_photos_preview_container', false)">
                                <div id="adversary_extra_photos_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Photos Renforts Potentiels</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('renforts_photo_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="renforts_photo_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'renforts_photo_preview_container', false)">
                                <div id="renforts_photo_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Articulation</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                             <div class="photo-upload-section">
                                <h4>Itinéraire Extérieur (INDIA)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_itineraire_exterieur_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_itineraire_exterieur_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_itineraire_exterieur_preview_container', false)">
                                <div id="photo_container_itineraire_exterieur_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Itinéraire Intérieur (INDIA)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_itineraire_interieur_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_itineraire_interieur_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_itineraire_interieur_preview_container', false)">
                                <div id="photo_container_itineraire_interieur_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Baptême Terrain (AO)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_bapteme_terrain_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_bapteme_terrain_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_bapteme_terrain_preview_container', false)">
                                <div id="photo_container_bapteme_terrain_preview_container" class="image-preview-container"></div>
                            </div>
                            <div class="photo-upload-section">
                                <h4>Emplacement (AO)</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_emplacement_ao_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_emplacement_ao_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_emplacement_ao_preview_container', false)">
                                <div id="photo_container_emplacement_ao_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                
                    <div class="collapsible-container">
                        <div class="collapsible-header">
                            <h3>Logistique & Divers</h3>
                            <span class="material-symbols-outlined">expand_more</span>
                        </div>
                        <div class="collapsible-content" style="display: flex; flex-direction: column; gap: 15px;">
                           <div class="photo-upload-section">
                                <h4>Transport PSIG vers PR</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_transport_pr_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_transport_pr_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_transport_pr_preview_container', false)">
                                <div id="photo_container_transport_pr_preview_container" class="image-preview-container"></div>
                            </div>
                           <div class="photo-upload-section">
                                <h4>Transport PR vers Domicile</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_transport_domicile_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_transport_domicile_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_transport_domicile_preview_container', false)">
                                <div id="photo_container_transport_domicile_preview_container" class="image-preview-container"></div>
                            </div>
                             <div class="photo-upload-section">
                                <h4>Cellule Effraction</h4>
                                <button type="button" class="add-btn" style="width:100%; justify-content: center;" onclick="document.getElementById('photo_container_cellule_effraction_input').click()">➕ Ajouter Photo(s)</button>
                                <input type="file" id="photo_container_cellule_effraction_input" class="photo-input" accept="image/jpeg, image/png" multiple onchange="handleFileChange(this, 'photo_container_cellule_effraction_preview_container', false)">
                                <div id="photo_container_cellule_effraction_preview_container" class="image-preview-container"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="wizard-step">
                    <h2>9. Conduites à tenir</h2>
                    <h3>Générales</h3>
                    <textarea id="cat_generales" rows="6">- Si rébellion, user du strict niveau de force nécessaire
- Si retranché, alerter en mesure de se ré-articuler
- Si tente de fuir, alerter en mesure de jalonner/interpeller
- UDA : Article L435-1 du CSI + légitime défense</textarea>
                    
                    <h3>NO GO</h3>
                    <textarea id="no_go" rows="3" placeholder="Saisir les conditions de désengagement..."></textarea>
                    <h3>Liaison</h3>
                    <textarea id="cat_liaison" rows="4">TOM: 
DIR: 
Gestuelle et visuelle entre les éléments INDIA</textarea>
                </div>
                
                <div class="wizard-step">
                    <h2>10. Finalisation</h2>
                    <p style="text-align:center;">Vérifiez les points de cohérence avant de générer l'Ordre Initial.</p>
                    
                    <div style="border: 1px solid var(--border-color); padding: 15px; border-radius: 5px; margin-top: 20px;">
                        <h3>Vérification des Données Critiques</h3>
                        <div id="coherence_alerts_container">
                             <div class="coherence-alert" style="color:var(--text-secondary); background-color:var(--bg-interactive);"><span class="material-symbols-outlined">info</span> Cliquez sur "Aperçu" pour lancer la vérification de cohérence.</div>
                        </div>
                        <div id="recap_finalisation" style="margin-top: 15px;">
                            </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 20px;">
                        <button class="wizard-nav-btn" id="previewBtn" type="button">Aperçu (Mode Présentation) 🔎</button>
                        </div>
                    
                    <div class="retex-section">
                        <h3>Lien vers RETEX</h3>
                        <p>Utilisez ce bouton pour afficher la page vers la plateforme interne de compte-rendu d'opération.</p>
                        <div class="retex-actions">
                            <button id="retexReportBtn" class="wizard-nav-btn" type="button" style="background-color: #008080;">Page Retex 🧠</button>
                        </div>
                    </div>
                    <div class="retex-section" style="margin-top: 10px;">
                        <h3>🧠 Analyse RETEX par IA (Fichiers locaux)</h3>
                        <p>Sélectionnez les fichiers JSON des comptes-rendus à analyser localement (Nécessite Clé API Gemini).</p>
                        <div class="retex-file-selector">
                            <label for="retexFileInput" class="file-upload-label" style="background-color: var(--accent-blue);">
                                <span class="material-symbols-outlined">upload_file</span> Choisir des fichiers
                            </label>
                            <input type="file" id="retexFileInput" accept=".json" multiple style="display: none;">
                            <span id="retexFileNames" class="file-name-display" style="color: var(--text-secondary);">Aucun fichier sélectionné</span>
                        </div>
                        <div class="retex-actions">
                             <button id="launchRetexAnalysisBtn" class="add-btn" type="button">Lancer l'Analyse</button>
                            <button id="generateRetexPdfBtn" class="wizard-nav-btn" style="display: none; background-color: var(--success-green);">Générer le PDF du rapport</button>
                        </div>
                        <p id="retex_status" class="retex-status"></p>
                        <div id="retex_output" class="retex-output-content" style="display: none;"></div>
                    </div>
                    </div>
            </div>
        </form>

        <div class="wizard-nav">
            <button class="wizard-nav-btn" id="prevBtn" type="button">Précédent</button>
            <button class="wizard-nav-btn" id="nextBtn" type="button">Suivant</button>
        </div>
    </div>

    <script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@4.0.10/marked.min.js"></script>
    <script src="https://unpkg.com/jspdf@latest/dist/jspdf.umd.min.js"></script>
    <script src="https://unpkg.com/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <script>
        const GEMINI_API_URL = "https://generativelanguage.googleapis.com/v1/models/gemini-2.5-flash:generateContent";
        const RETEX_BASE_URL = "https://oxsilaris06.github.io/Praxis/retex.html";
        const DEFAULT_CONFIG_FILE = 'members_config.json'; 
        
        let memberConfig = {
            fonctions: ['Chef inter', 'Chef dispo','Chef AO','Effrac', 'DE', 'Sans'],
            cellules: ['AO1','AO2','AO3','AO4','AO5','AO6','India 1','India 2','India 3','India 4','India 5', 'Sans'],
            armements: ['PSA', 'UMP9', 'G36', 'PIE', 'LBD40', 'FAP'],
            equipements: ['Sans', 'BBAL', 'GENL', 'EFFRAC', 'MP7', 'IL'],
            equipements2: ['Sans', 'Échelle', 'Stop stick', 'Lacry', 'Cale'],
            tenues: ['UBAS', '4S', 'Bleu', 'Treillis','Ghilie', 'Civil'],
            gpbs: ['GPBL', 'GPBPD','Sans']
        };
        const availableVehicles = ['Sharan', 'Kodiaq', '5008', 'Scénic', 'BT'];
        
        let activeMemberId = null;

        let currentStep = 0;
        let visitedSteps = new Set();
        const steps = Array.from(document.querySelectorAll(".wizard-step"));
        const progressSteps = Array.from(document.querySelectorAll(".wizard-progress-step"));
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const previewBtn = document.getElementById('previewBtn');
        const retexReportBtn = document.getElementById('retexReportBtn');
        const retexStatus = document.getElementById('retex_status');
        const retexOutput = document.getElementById('retex_output');
        const launchRetexAnalysisBtn = document.getElementById('launchRetexAnalysisBtn');
        const generateRetexPdfBtn = document.getElementById('generateRetexPdfBtn');
        const patracdvrContainer = document.getElementById('patracdvr_container');
        const unassignedContainer = document.getElementById('unassigned_members_container');
        const jsonConfigInput = document.getElementById('jsonConfigInput');
        const resetPatracdvrBtn = document.getElementById('resetPatracdvrBtn');
        const importJsonConfigBtn = document.getElementById('importJsonConfigBtn');
        const importDefaultConfigBtn = document.getElementById('importDefaultConfigBtn');
        
        const retexFileInput = document.getElementById('retexFileInput');
        const retexFileNames = document.getElementById('retexFileNames');
        
        const presentationModal = document.getElementById('presentationModal'); 
        const downloadPdfBtn = document.getElementById('downloadPdfBtn'); 
        
        const coherenceAlertsContainer = document.getElementById('coherence_alerts_container');
        const recapFinalisation = document.getElementById('recap_finalisation');

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        /**
         * Gestionnaire IndexedDB pour le stockage des images.
         */
        const dbManager = {
            db: null,
            dbName: 'OI_GeneratorDB',
            storeName: 'images',
        
            init() {
                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.dbName, 1);
        
                    request.onerror = (event) => {
                        console.error("Erreur d'ouverture de la base de données IndexedDB", event);
                        reject("Erreur IndexedDB.");
                    };
        
                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve(this.db);
                    };
        
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName);
                        }
                    };
                });
            },
        
            putImage(key, blob) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.put(blob, key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            },
        
            getImage(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readonly');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.get(key);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            
            deleteImage(key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            },
            
            clearAllImages() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([this.storeName], 'readwrite');
                    const store = transaction.objectStore(this.storeName);
                    const request = store.clear();
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
            }
        };


        const displayMap = {
            'adversary_photo_preview_container': 'adversary_photo_display',
            'adversary_extra_photos_preview_container': 'adversary_extra_photos_display',
            'renforts_photo_preview_container': 'renforts_photo_display',
            'photo_container_itineraire_exterieur_preview_container': 'photo_container_itineraire_exterieur_display',
            'photo_container_itineraire_interieur_preview_container': 'photo_container_itineraire_interieur_display',
            'photo_container_bapteme_terrain_preview_container': 'photo_container_bapteme_terrain_display',
            'photo_container_emplacement_ao_preview_container': 'photo_container_emplacement_ao_display',
            'photo_container_transport_pr_preview_container': null,
            'photo_container_transport_domicile_preview_container': null,
            'photo_container_cellule_effraction_preview_container': null,
        };

        function showStep(n) {
            steps.forEach((step, index) => step.classList.toggle('active', index === n));
            progressSteps.forEach((pStep, index) => {
                pStep.classList.toggle('active', index === n);
                if(visitedSteps.has(index) && index !== n) pStep.classList.add('completed');
                else pStep.classList.remove('completed');
            });
            prevBtn.style.display = n === 0 ? "none" : "inline-block";
            const isLastStep = n === (steps.length - 1);
            nextBtn.style.display = isLastStep ? "none" : "inline-block";
            
            if (n === 9) {
                previewBtn.style.display = "inline-block";
                retexReportBtn.style.display = "inline-block";
                checkCoherence(); 
            } else {
                previewBtn.style.display = "none";
                retexReportBtn.style.display = "none";
            }
        }
        function goToStep(n) {
            if (n >= 0 && n < steps.length) {
                visitedSteps.add(currentStep);
                currentStep = n;
                showStep(n);
            }
        }
        function changeStep(n) { goToStep(currentStep + n); }
        prevBtn.addEventListener('click', () => changeStep(-1));
        nextBtn.addEventListener('click', () => changeStep(1));
        
        async function handleFileChange(input, previewContainerId, isSingle) {
            const previewContainer = document.getElementById(previewContainerId);
            
            if (isSingle) {
                // Supprimer les anciennes images de l'UI et de la DB
                const existingImages = previewContainer.querySelectorAll('.image-preview');
                for (const img of existingImages) {
                    await dbManager.deleteImage(img.id);
                }
                previewContainer.innerHTML = '';
            }
        
            if (input.files.length > 0) {
                for (const file of Array.from(input.files)) {
                    const previewImgId = `img_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
        
                    try {
                        // Stocker le blob dans IndexedDB
                        await dbManager.putImage(previewImgId, file);
        
                        // Créer l'URL d'objet pour l'affichage immédiat
                        const objectURL = URL.createObjectURL(file);
        
                        const interactiveItem = document.createElement('div');
                        interactiveItem.className = 'image-preview-item';
                        interactiveItem.innerHTML = `
                            <img id="${previewImgId}" class="image-preview" src="${objectURL}" style="display:block;" data-annotations="[]">
                            <div style="display: flex; gap: 5px; margin-top: 5px;">
                                <button type="button" class="add-btn" style="background-color: var(--accent-blue); padding: 4px 8px;" onclick="openAnnotationModal('${previewImgId}')"><span class="material-symbols-outlined" style="font-size: 1.2em;">edit</span></button>
                                <button type="button" class="remove-btn" style="padding: 4px 8px;" onclick="removeImage('${previewImgId}', this)">&times;</button>
                            </div>`;
                        previewContainer.appendChild(interactiveItem);
        
                    } catch (error) {
                        console.error("Erreur lors du stockage de l'image:", error);
                        alert("Une erreur est survenue lors de l'ajout de l'image.");
                    }
                }
            }
            syncAllThumbnails();
            input.value = '';
            saveFormData();
        }
        
        async function removeImage(imgId, buttonElement) {
            try {
                // Supprimer de IndexedDB
                await dbManager.deleteImage(imgId);
        
                // Supprimer de l'UI
                buttonElement.closest('.image-preview-item').remove();
        
                // Mettre à jour les aperçus
                syncAllThumbnails();
        
                // Sauvegarder les métadonnées
                saveFormData();
            } catch (error) {
                console.error("Erreur lors de la suppression de l'image:", error);
                alert("Impossible de supprimer l'image.");
            }
        }
        
        function syncAllThumbnails() {
            // D'abord, on vide tous les conteneurs d'aperçu
            document.querySelectorAll('.photo-display-area').forEach(container => {
                container.innerHTML = '';
            });
        
            // Ensuite, on les repeuple à partir des conteneurs de gestion
            for (const previewId in displayMap) {
                const displayId = displayMap[previewId];
                if (!displayId) continue;
        
                const previewContainer = document.getElementById(previewId);
                const displayContainer = document.getElementById(displayId);
        
                if (previewContainer && displayContainer) {
                    previewContainer.querySelectorAll('.image-preview-item img').forEach(previewImg => {
                        const displayImg = document.createElement('img');
                        displayImg.className = 'image-preview';
                        displayImg.src = previewImg.src; 
                        displayImg.dataset.refId = previewImg.id;
                        displayContainer.appendChild(displayImg);
                    });
                }
            }
        }


        function addDynamicField(containerId, value = '') {
            const container = document.getElementById(containerId);
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `<input type="text" class="dynamic-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }

        function initChipContainer(containerId, selectedValues = []) {
             const container = document.getElementById(containerId);
             const options = JSON.parse(container.dataset.options || '[]');
             container.innerHTML = ''; 

             options.forEach(option => {
                 const btn = document.createElement('button');
                 btn.type = 'button';
                 btn.className = 'chip-btn';
                 btn.textContent = option;
                 if (selectedValues.includes(option)) {
                     btn.classList.add('selected');
                 }
                 btn.addEventListener('click', function() {
                     this.classList.toggle('selected');
                     saveFormData();
                 });
                 container.appendChild(btn);
             });

             const customInput = document.createElement('input');
             customInput.type = 'text';
             customInput.placeholder = 'Ajouter personnalisé (entrée)';
             customInput.onkeydown = function(event) {
                 if (event.key === 'Enter' && this.value.trim()) {
                     event.preventDefault(); 
                     const customValue = this.value.trim();
                     if (!options.includes(customValue) && !getChipData(containerId).includes(customValue)) {
                         const newBtn = document.createElement('button');
                         newBtn.type = 'button';
                         newBtn.className = 'chip-btn selected';
                         newBtn.textContent = customValue;
                         newBtn.addEventListener('click', btn.onclick);
                         container.insertBefore(newBtn, this);
                     }
                     this.value = '';
                     saveFormData();
                 }
             };
             customInput.style.flexBasis = '150px';
             customInput.style.flexGrow = '0';
             customInput.style.minHeight = '40px';
             customInput.style.padding = '8px 12px';
             container.appendChild(customInput);
         }

         function getChipData(containerId) {
             const container = document.getElementById(containerId);
             const selectedChips = container.querySelectorAll('.chip-btn.selected');
             return Array.from(selectedChips).map(btn => btn.textContent);
         }

        function addMeField(value = '') {
            const container = document.getElementById('me_container');
            if (container.children.length >= 3) return;
            const item = document.createElement('div');
            item.className = 'dynamic-list-item';
            item.innerHTML = `<label>ME${container.children.length + 1}:</label><input type="text" class="me-input" value="${value}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }
        
        function addTimeEvent(type_from_load, hour_from_load = '', desc_from_load) {
            const container = document.getElementById('time_events_container');
            const isLoadingFromFile = type_from_load !== undefined;

            let type, hour = hour_from_load, desc;

            if (isLoadingFromFile) {
                type = type_from_load;
                desc = desc_from_load;
            } else {
                const currentEventCount = container.children.length;
                const prefilledData = [
                    { type: 'T0', desc: 'Rasso PSIG' }, { type: 'T1', desc: 'Départ PR' },
                    { type: 'T2', desc: 'Départ LE' }, { type: 'T3', desc: 'MEP TERMINÉ' },
                    { type: 'T4', desc: 'TOP ACTION' },
                ];
                const defaultValues = prefilledData[currentEventCount] || { type: `T${currentEventCount}`, desc: ''};
                type = defaultValues.type;
                desc = defaultValues.desc;
            }

            const item = document.createElement('div');
            item.className = 'dynamic-list-item time-item draggable';
            item.id = `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            item.setAttribute('draggable', 'true');
            const optionsHtml = ['T0','T1','T2','T3','T4','T5'].map(t => 
                `<option value="${t}" ${t === type ? 'selected' : ''}>${t}</option>`
            ).join('');
            item.innerHTML = `<select class="time-type-select" onchange="saveFormData()">${optionsHtml}</select><input type="time" class="time-hour-input" value="${hour}" onchange="saveFormData()"><input type="text" class="time-description-input" placeholder="Description" value="${desc || ''}" oninput="saveFormData()"><button type="button" class="remove-btn" onclick="this.parentElement.remove(); saveFormData();">❌</button>`;
            container.appendChild(item);
        }

        function addPatracdvrRow(vehicleName, members = []) {
            const container = document.getElementById('patracdvr_container');
            if (container.querySelector(`[data-vehicle-name="${vehicleName}"]`)) {
                alert(`Le véhicule "${vehicleName}" existe déjà. Veuillez choisir un nom unique.`);
                return;
            }
            const row = document.createElement('div');
            row.className = 'patracdvr-vehicle-row';
            row.dataset.vehicleName = vehicleName;

            row.innerHTML = `
                <div class="vehicle-header">
                    <span class="vehicle-name">${vehicleName}</span>
                    <button type="button" class="remove-btn" title="Supprimer le véhicule">❌</button>
                </div>
                <div class="patracdvr-members-container"></div>`;
            
            container.appendChild(row);

            const membersContainer = row.querySelector('.patracdvr-members-container');
            row.querySelector('.remove-btn').addEventListener('click', () => {
                const confirmation = confirm(`Voulez-vous vraiment supprimer le véhicule "${vehicleName}" et désattribuer ses membres ?`);
                if (confirmation) {
                    membersContainer.querySelectorAll('.patracdvr-member-btn').forEach(memberBtn => {
                        memberBtn.dataset.cellule = 'Sans';
                        memberBtn.dataset.fonction = 'Sans';
                        updateMemberButtonVisuals(memberBtn);
                        unassignedContainer.appendChild(memberBtn);
                    });
                    row.remove();
                    saveFormData();
                }
            });
            
            membersContainer.addEventListener('dragenter', handleDragEnter);
            membersContainer.addEventListener('dragleave', handleDragLeave);
            membersContainer.addEventListener('dragover', handleDragOver);
            membersContainer.addEventListener('drop', handleDrop);

            members.forEach(memberData => addPatracdvrMember(membersContainer, memberData));
            saveFormData();
        }
        
        function addManualVehicle() {
            let vehicleName = prompt("Veuillez saisir le nom du nouveau véhicule (ex: VW-Golf, VTC):");
            if (vehicleName) {
                vehicleName = vehicleName.trim();
                if (vehicleName.length > 0) {
                    addPatracdvrRow(vehicleName);
                }
            }
        }
        
        function addManualMember() {
            let trigramme = prompt("Veuillez saisir le trigramme du nouveau membre (ex: ABC):");
            if (trigramme) {
                trigramme = trigramme.trim().toUpperCase();
                const existingMember = document.querySelector(`.patracdvr-member-btn[data-trigramme="${trigramme}"]`);
                if (existingMember) {
                    alert(`Le membre avec le trigramme "${trigramme}" existe déjà. Veuillez en choisir un autre.`);
                    return;
                }
                
                if (trigramme.length >= 2 && trigramme.length <= 4) {
                    addPatracdvrMember(unassignedContainer, { trigramme: trigramme, cellule: 'Sans', fonction: 'Sans' });
                    
                    const newMemberBtn = unassignedContainer.lastChild;
                    if (newMemberBtn) {
                        handleMemberSelection({ target: newMemberBtn });
                    }
                    saveFormData();
                } else {
                    alert("Le trigramme doit contenir entre 2 et 4 caractères.");
                }
            }
        }
        
        function addPatracdvrMember(containerElement, data = {}) {
            if (!containerElement) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'patracdvr-member-btn draggable';
            btn.id = `member_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            btn.setAttribute('draggable', 'true');
            const memberData = {
                trigramme: 'N/A', fonction: 'Sans', cellule: 'India 1', armement: 'Sans',
                equipement: 'Sans', equipement2: 'Sans',
                tenue: 'UBAS', gpb: 'GPBL', ...data
            };
            Object.keys(memberData).forEach(key => btn.dataset[key] = memberData[key]);
            updateMemberButtonVisuals(btn);
            containerElement.appendChild(btn);
        }
        function updateMemberButtonVisuals(btn) {
            const trigramme = btn.dataset.trigramme || 'N/A';
            const fonction = btn.dataset.fonction || '';
            const cellule = btn.dataset.cellule || '';
            const cellDisplay = cellule !== 'Sans' ? cellule : '';
            const functionDisplay = fonction !== 'Sans' ? ` / ${fonction}` : '';
            const separation = (cellDisplay && functionDisplay) ? '' : ''; 
            
            btn.innerHTML = `<span class="trigramme">${trigramme}</span><span class="fonction">${cellDisplay}${separation}${functionDisplay}</span>`;
            
            if (btn.closest('#unassigned_members_container')) {
                btn.innerHTML = `<span class="trigramme">${trigramme}</span>`;
            }
        }

        function openMemberModal(buttonId) {
            const modal = document.getElementById('editMemberModal');
            const form = document.getElementById('editMemberForm');
            const button = document.getElementById(buttonId);
            const deleteBtn = document.getElementById('modal_deleteBtn');
            
            if (!button) return;
            form.dataset.editingButtonId = buttonId;
            
            const isUnassigned = button.closest('#unassigned_members_container');
            
            if (isUnassigned) {
                deleteBtn.textContent = 'Supprimer Définitivement';
                deleteBtn.style.backgroundColor = '#FF0000'; 
            } else {
                deleteBtn.textContent = 'Renvoyer en Attente';
                deleteBtn.style.backgroundColor = 'var(--danger-red)'; 
            }
            
            document.getElementById('modal_trigramme').value = button.dataset.trigramme;
            
            for (const key in memberConfig) {
                const attrName = key.replace(/s$/, ''); 
                const selectId = 'modal_' + attrName;
                const select = document.getElementById(selectId);
                if (select) {
                    select.innerHTML = memberConfig[key].map(option => {
                        const selected = (button.dataset[attrName] === option) ? 'selected' : '';
                        return `<option value="${option}" ${option === button.dataset[attrName] ? 'selected':''}>${option}</option>`;
                    }).join('');
                    select.value = button.dataset[attrName];
                }
            }
            
            modal.showModal();
        }
        
        function updateArticulationDisplay() {
            const indiaContainer = document.getElementById('india_composition_display');
            const aoContainer = document.getElementById('ao_composition_display');
            
            const indiaMembersByCell = {};
            const aoMembersByCell = {};

            document.querySelectorAll('.patracdvr-member-btn').forEach(btn => {
                const trigramme = btn.dataset.trigramme;
                const cellule = btn.dataset.cellule;
                if (!trigramme || !cellule || cellule.toLowerCase() === 'sans') return;

                if (cellule.toLowerCase().startsWith('india')) {
                    if (!indiaMembersByCell[cellule]) {
                        indiaMembersByCell[cellule] = [];
                    }
                    indiaMembersByCell[cellule].push(trigramme);
                } else if (cellule.toLowerCase().startsWith('ao')) {
                    if (!aoMembersByCell[cellule]) {
                        aoMembersByCell[cellule] = [];
                    }
                    aoMembersByCell[cellule].push(trigramme);
                }
            });

            const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
            
            let indiaHtml = '';
            const sortedIndiaKeys = Object.keys(indiaMembersByCell).sort(naturalSort);
            sortedIndiaKeys.forEach(cell => {
                indiaHtml += `<p><strong>${cell}:</strong> ${indiaMembersByCell[cell].join(', ')}</p>`;
            });
            indiaContainer.innerHTML = indiaHtml || `<p><i>Aucun membre assigné aux cellules India.</i></p>`;

            let aoHtml = '';
            const sortedAoKeys = Object.keys(aoMembersByCell).sort(naturalSort);
            sortedAoKeys.forEach(cell => {
                aoHtml += `<p><strong>${cell}:</strong> ${aoMembersByCell[cell].join(', ')}</p>`;
            });
            aoContainer.innerHTML = aoHtml || `<p><i>Aucun membre assigné aux cellules AO.</i></p>`;
        }

        const quickEditMapping = {
            'Cellule': { key: 'cellules', attribute: 'cellule' },
            'Fonction': { key: 'fonctions', attribute: 'fonction' },
            'Armement': { key: 'armements', attribute: 'armement' },
            'Équip. 1': { key: 'equipements', attribute: 'equipement' },
            'Équip. 2': { key: 'equipements2', attribute: 'equipement2' },
            'Tenue': { key: 'tenues', attribute: 'tenue' },
            'GPB': { key: 'gpbs', attribute: 'gpb' }
        };
        
        function setupQuickEditPanel() {
            const contentContainer = document.querySelector('#quickEditPanel .quick-edit-content');
            contentContainer.innerHTML = '';
            
            for (const [title, config] of Object.entries(quickEditMapping)) {
                
                const tabPanel = document.createElement('div');
                tabPanel.className = 'quick-edit-tab-panel active';
                
                const panelTitle = document.createElement('h5');
                panelTitle.textContent = title;
                tabPanel.appendChild(panelTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = config.attribute;
                    btn.dataset.value = option;
                    optionsContainer.appendChild(btn);
                });
                
                tabPanel.appendChild(optionsContainer);
                contentContainer.appendChild(tabPanel);
            }
        }
        
        function handleMemberSelection(event) {
            const clickedButton = event.target.closest('.patracdvr-member-btn');
            if (!clickedButton) return;

            if (activeMemberId === clickedButton.id) {
                clickedButton.classList.remove('member-active');
                activeMemberId = null;
                document.getElementById('quickEditPanel').style.display = 'none';
                return;
            }

            if (activeMemberId) {
                const oldActive = document.getElementById(activeMemberId);
                if (oldActive) oldActive.classList.remove('member-active');
            }
            
            activeMemberId = clickedButton.id;
            clickedButton.classList.add('member-active');
            
            if (window.innerWidth < 768) {
                openQuickEditModal(activeMemberId);
            } else {
                populateQuickEditPanel(activeMemberId);
                document.getElementById('quickEditPanel').style.display = 'block';
            }
        }
        
        function populateQuickEditPanel(memberId) {
            const member = document.getElementById(memberId);
            if (!member) return;
            document.getElementById('selectedMemberTrigramme').textContent = member.dataset.trigramme || 'N/A';
            document.querySelectorAll('#quickEditPanel .quick-edit-btn').forEach(btn => {
                const attribute = btn.dataset.attribute;
                const value = btn.dataset.value;
                btn.classList.toggle('selected', member.dataset[attribute] === value);
            });
        }

        function openQuickEditModal(memberId) {
            const modal = document.getElementById('quickEditModal');
            const title = document.getElementById('quick_modal_title');
            const content = document.getElementById('quick_modal_content');
            const member = document.getElementById(memberId);

            if (!member) return;

            title.textContent = `Édition Rapide: ${member.dataset.trigramme || 'N/A'}`;
            content.innerHTML = '';

            for (const [category, config] of Object.entries(quickEditMapping)) {
                 if (!memberConfig[config.key] || memberConfig[config.key].length === 0) continue;
                 
                const attributeName = config.attribute; 
                
                const categoryDiv = document.createElement('div');
                categoryDiv.className = 'quick-edit-category';
                
                const categoryTitle = document.createElement('h5');
                categoryTitle.textContent = category;
                categoryDiv.appendChild(categoryTitle);
                
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'quick-edit-options';
                
                (memberConfig[config.key] || []).forEach(option => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'quick-edit-btn';
                    btn.textContent = option;
                    btn.dataset.attribute = attributeName;
                    btn.dataset.value = option;
                    if (member.dataset[attributeName] === option) {
                        btn.classList.add('selected');
                    }
                    optionsContainer.appendChild(btn);
                });
                
                categoryDiv.appendChild(optionsContainer);
                content.appendChild(categoryDiv);
            }
            modal.showModal();
        }

        /**
         * Sauvegarde les métadonnées du formulaire dans localStorage.
         * Les données d'image (blobs) sont déjà dans IndexedDB.
         */
        function saveFormData() {
            try {
                const data = {};
                document.querySelectorAll('#oi-form input:not([type="file"]), #oi-form textarea, #oi-form select').forEach(field => {
                    if (field.id) data[field.id] = field.value;
                });
        
                data.dynamic_photos = {};
                document.querySelectorAll('.image-preview-container').forEach(container => {
                    if (container.id) {
                        const imagesMetadata = Array.from(container.querySelectorAll('.image-preview')).map(img => ({
                            id: img.id,
                            annotations: img.dataset.annotations || '[]'
                        }));
                        if (imagesMetadata.length > 0) {
                            data.dynamic_photos[container.id] = imagesMetadata;
                        }
                    }
                });
                
                data.me_list = Array.from(document.querySelectorAll('#me_container .me-input')).map(i => i.value).filter(Boolean);
                data.etat_esprit_list = getChipData('etat_esprit_container');
                data.volume_list = getChipData('volume_adversaire_container');
                data.vehicules_list = Array.from(document.querySelectorAll(`#vehicules_container .dynamic-input`)).map(i => i.value).filter(Boolean);
                data.patracdvr_unassigned = Array.from(unassignedContainer.querySelectorAll('.patracdvr-member-btn')).map(btn => ({ ...btn.dataset }));
                data.patracdvr_rows = Array.from(document.querySelectorAll('#patracdvr_container .patracdvr-vehicle-row')).map(row => ({
                    vehicle: row.dataset.vehicleName,
                    members: Array.from(row.querySelectorAll('.patracdvr-member-btn')).map(btn => ({ ...btn.dataset }))
                }));
                data.time_events = Array.from(document.querySelectorAll('#time_events_container .time-item')).map(item => ({
                    type: item.querySelector('.time-type-select').value,
                    hour: item.querySelector('.time-hour-input').value,
                    description: item.querySelector('.time-description-input').value
                }));

                localStorage.setItem('oiFormData', JSON.stringify(data));
                updateArticulationDisplay();
        
            } catch (e) { 
                console.error("Erreur de sauvegarde:", e); 
            }
        }
        
        /**
         * Charge les données du formulaire depuis localStorage et les images depuis IndexedDB.
         */
        async function loadFormData() {
            const dataString = localStorage.getItem('oiFormData');
            if (!dataString) return false;
        
            try {
                const data = JSON.parse(dataString);
        
                // Nettoyer l'UI
                document.querySelectorAll('.image-preview-container, .photo-display-area').forEach(c => c.innerHTML = '');
        
                // Charger les métadonnées de base
                Object.keys(data).forEach(key => {
                     if (['dynamic_photos', 'patracdvr_rows', 'patracdvr_unassigned', 'time_events', 'me_list', 'etat_esprit_list', 'volume_list', 'vehicules_list'].includes(key)) return; 
                     const el = document.getElementById(key);
                     if (el) el.value = data[key];
                });
        
                // Charger les photos depuis IndexedDB en utilisant les métadonnées
                if (data.dynamic_photos) {
                    for (const previewId in data.dynamic_photos) {
                        const previewContainer = document.getElementById(previewId);
                        const fileDataArray = data.dynamic_photos[previewId];
        
                        if (previewContainer && fileDataArray) {
                            for (const imgData of fileDataArray) {
                                const imageBlob = await dbManager.getImage(imgData.id);
                                if (imageBlob) {
                                    const objectURL = URL.createObjectURL(imageBlob);
                                    const interactiveItem = document.createElement('div');
                                    interactiveItem.className = 'image-preview-item';
                                    interactiveItem.innerHTML = `
                                        <img id="${imgData.id}" class="image-preview" src="${objectURL}" style="display:block;" data-annotations='${imgData.annotations}'>
                                        <div style="display: flex; gap: 5px; margin-top: 5px;">
                                            <button type="button" class="add-btn" style="background-color: var(--accent-blue); padding: 4px 8px;" onclick="openAnnotationModal('${imgData.id}')"><span class="material-symbols-outlined" style="font-size: 1.2em;">edit</span></button>
                                            <button type="button" class="remove-btn" style="padding: 4px 8px;" onclick="removeImage('${imgData.id}', this)">&times;</button>
                                        </div>`;
                                    previewContainer.appendChild(interactiveItem);
                                } else {
                                     console.warn(`Image avec ID ${imgData.id} non trouvée dans IndexedDB.`);
                                }
                            }
                        }
                    }
                }
                syncAllThumbnails();
                
                // Charger les autres champs dynamiques
                document.getElementById('me_container').innerHTML = '';
                document.getElementById('vehicules_container').innerHTML = '';
                document.getElementById('time_events_container').innerHTML = '';
                
                (data.me_list || []).forEach(val => addMeField(val));
                initChipContainer('etat_esprit_container', data.etat_esprit_list || []);
                initChipContainer('volume_adversaire_container', data.volume_list || []);
                (data.vehicules_list || []).forEach(val => addDynamicField('vehicules_container', val));
                (data.time_events || []).forEach(ev => addTimeEvent(ev.type, ev.hour, ev.description));
                initializePatracdvr(data);
        
                updateArticulationDisplay();
                return true;
        
            } catch (e) {
                console.error("Erreur de chargement:", e);
                return false;
            }
        }
        
        function initializePatracdvr(dataFromStorage) {
            unassignedContainer.innerHTML = '';
            patracdvrContainer.innerHTML = '';
            if (dataFromStorage && (dataFromStorage.patracdvr_rows?.length > 0 || dataFromStorage.patracdvr_unassigned?.length > 0)) {
                (dataFromStorage.patracdvr_unassigned || []).forEach(member => addPatracdvrMember(unassignedContainer, member));
                (dataFromStorage.patracdvr_rows || []).forEach(row => addPatracdvrRow(row.vehicle, row.members));
            }
        }
        
        function loadConfigObject(config) {
            if (config.options) {
                Object.assign(memberConfig, config.options);
                setupQuickEditPanel(); 
                const modal = document.getElementById('editMemberModal'); 
                const form = document.getElementById('editMemberForm');
                if (form.dataset.editingButtonId) {
                    openMemberModal(form.dataset.editingButtonId);
                }
            }
            
            if (config.members && Array.isArray(config.members)) {
                unassignedContainer.innerHTML = ''; 
                patracdvrContainer.innerHTML = '';
                config.members.forEach(memberData => { 
                    const defaultData = {
                        cellule: memberData.cellule || 'Sans',
                        fonction: memberData.fonction || 'Sans',
                        ...memberData
                    };
                    addPatracdvrMember(unassignedContainer, defaultData); 
                });
            }
            saveFormData(); 
        }

        async function loadDefaultConfig() {
            try {
                const response = await fetch(DEFAULT_CONFIG_FILE);
                if (!response.ok && response.status !== 404) {
                    throw new Error(`Échec du chargement de ${DEFAULT_CONFIG_FILE}`);
                }
                if (response.status !== 404) {
                    const config = await response.json();
                    loadConfigObject(config);
                }
            } catch (e) {
                console.warn(`[Config Info] Impossible de charger la configuration par défaut (${DEFAULT_CONFIG_FILE}). Utilisation de la configuration interne.`, e);
                setupQuickEditPanel(); 
            }
        }

        let draggedItem = null;

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.draggable:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } 
                else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        function handleDragEnter(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                targetContainer.style.border = '2px dashed var(--accent-blue)';
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); 
            const targetContainer = e.currentTarget;
            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                const afterElement = getDragAfterElement(targetContainer, e.clientY);
                if (afterElement == null) { 
                    targetContainer.appendChild(draggedItem); 
                } else { 
                    targetContainer.insertBefore(draggedItem, afterElement); 
                }
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.style.border = '1px dashed var(--border-color)';
        }

        function handleDrop(e) {
            e.preventDefault();
            const targetContainer = e.currentTarget;
            targetContainer.style.border = '1px dashed var(--border-color)';

            if (draggedItem && draggedItem.classList.contains('patracdvr-member-btn')) {
                targetContainer.appendChild(draggedItem);

                const isUnassignedZone = targetContainer.id === 'unassigned_members_container';
                
                if (isUnassignedZone) {
                    draggedItem.dataset.cellule = 'Sans';
                    draggedItem.dataset.fonction = 'Sans';
                } else {
                    if (draggedItem.dataset.cellule === 'Sans') {
                         draggedItem.dataset.cellule = 'India 1'; 
                    }
                }
                
                updateMemberButtonVisuals(draggedItem);
                
                if (draggedItem.id === activeMemberId) {
                    draggedItem.classList.remove('member-active');
                    activeMemberId = null;
                    if (window.innerWidth >= 768) {
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }
                
                saveFormData();
                draggedItem = null; 
            }
        }

        const tutorialSteps = [
            { text: "Bienvenue dans le générateur d'Ordre Initial. Ce guide vous assistera dans la création de votre document opérationnel.", selector: '.container', center: true },
            { text: "Cette barre de progression indique les différentes sections de l'O.I. Vous pouvez cliquer sur une étape pour y naviguer directement.", selector: '.wizard-progress' },
            { text: "Remplissez les informations textuelles dans les onglets 1 à 7. Les aperçus des photos que vous ajouterez apparaîtront ici.", selector: '#date_op', step: 0 },
            { text: "L'onglet 'Photos' (étape 8) est désormais le seul endroit pour ajouter et gérer vos images. Cliquez sur un bouton pour sélectionner une ou plusieurs photos.", selector: '.wizard-step:nth-of-type(8)', step: 7 },
            { text: "Sur la page 'Photos', chaque image importée dispose de boutons pour l'annoter ou la supprimer individuellement.", selector: '#adversary_photo_preview_container', step: 7 },
            { text: "Une fois le formulaire complété, cette étape affichera les alertes de cohérence sur votre composition. Cliquez ensuite ici pour visualiser le document (Mode Présentation) et le télécharger au format PDF.", selector: '#previewBtn', step: 9 },
            { text: "Ce menu flottant offre un accès rapide aux fonctions globales: sauvegarder (exporter) ou charger (importer) une session, changer le thème, réinitialiser le formulaire, ou relancer ce tutoriel.", selector: '#dockMenu' }
        ];
        
        let currentTutorialStep = 0;
        const tutorialPopup = document.getElementById('tutorial-popup'); const popupText = document.getElementById('popup-text');
        const nextPopupBtn = document.getElementById('next-popup-btn'); const closePopupBtn = tutorialPopup.querySelector('.close-btn');
        let currentHighlightedElement = null;
        function startTutorial() { if (tutorialPopup.style.display === 'flex') { hideTutorial(); return; } goToStep(0); currentTutorialStep = 0; showTutorialStep(currentTutorialStep); }
        function showTutorialStep(stepIndex) {
            if (stepIndex >= tutorialSteps.length) { hideTutorial(); return; }
            const step = tutorialSteps[stepIndex];
            if (step.step !== undefined && step.step !== currentStep) { goToStep(step.step); setTimeout(() => showTutorialStep(stepIndex), 600); return; }
            if (currentHighlightedElement) { currentHighlightedElement.classList.remove('highlight-element'); }
            popupText.textContent = step.text; nextPopupBtn.textContent = stepIndex === tutorialSteps.length - 1 ? 'Terminer' : 'Suivant';
            if (step.center) {
                tutorialPopup.style.top = '50%'; tutorialPopup.style.left = '50%'; tutorialPopup.style.transform = 'translate(-50%, -50%)';
                tutorialPopup.style.display = 'flex'; currentHighlightedElement = null; return;
            }
            const targetElement = document.querySelector(step.selector);
            if (!targetElement) { console.warn(`Element non trouvé: ${step.selector}`); currentTutorialStep++; showTutorialStep(currentTutorialStep); return; }
            targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetElement.classList.add('highlight-element'); currentHighlightedElement = targetElement;
            const rect = targetElement.getBoundingClientRect(); const popupWidth = tutorialPopup.offsetWidth; const popupHeight = tutorialPopup.offsetHeight;
            let popupX = rect.left + window.scrollX + (rect.width / 2) - (popupWidth / 2);
            let popupY = rect.top + window.scrollY - popupHeight - 20;
            if (popupY < window.scrollY + 10) { popupY = rect.bottom + window.scrollY + 20; }
            if (popupX < 10) popupX = 10;
            if (popupX + popupWidth > window.innerWidth - 10) { popupX = window.innerWidth - popupWidth - 10; }
            tutorialPopup.style.top = `${popupY}px`; tutorialPopup.style.left = `${popupX}px`;
            tutorialPopup.style.transform = 'none'; tutorialPopup.style.display = 'flex';
        }
        function hideTutorial() { if (currentHighlightedElement) { currentHighlightedElement.classList.remove('highlight-element'); } tutorialPopup.style.display = 'none'; }
        nextPopupBtn.addEventListener('click', () => { currentTutorialStep++; showTutorialStep(currentTutorialStep); });
        closePopupBtn.addEventListener('click', hideTutorial);
        
        const annotationModal = document.getElementById('annotationModal');
        const canvas = document.getElementById('annotationCanvas');
        const ctx = canvas.getContext('2d');
        const baseImage = new Image();
        let annotations = [], currentTool = 'move', isDrawing = false, isDragging = false, startX, startY;
        let currentAnnotation = null, selectedAnnotation = null, dragOffsetX, dragOffsetY;
        const rotationInput = document.getElementById('rotation_input');
        let isMovingAnnotation = false;

        function setContextualTools(selection) {
            const contextualTools = document.getElementById('contextual_tools');
            if (selection) {
                contextualTools.classList.add('active');
                contextualTools.classList.toggle('location-selected', selection.type === 'location');
                rotationInput.value = Math.round((selection.rotation || 0) * 180 / Math.PI) % 360;
                if (rotationInput.value < 0) rotationInput.value = 360 + parseInt(rotationInput.value);
            } else {
                contextualTools.classList.remove('active');
            }
        }
        
        function updateAnnotationRotation() {
            if (selectedAnnotation) {
                const degrees = parseFloat(rotationInput.value) || 0;
                selectedAnnotation.rotation = degrees * Math.PI / 180;
                redrawCanvas();
            }
        }

        function setActiveTool(toolId) {
            currentTool = toolId;
            document.querySelectorAll('.tool-btn.active, .tool-controls.active').forEach(el => el.classList.remove('active'));
            const toolButton = document.getElementById(`tool_${toolId}`);
            if (toolButton) toolButton.classList.add('active');
            const toolControls = document.getElementById(`controls_${toolId}`);
            if (toolControls) toolControls.classList.add('active');
            canvas.style.cursor = toolId === 'move' ? 'grab' : 'crosshair'; 
            selectedAnnotation = null;
            setContextualTools(null);
        }

        function openAnnotationModal(previewImgId) {
            const previewImg = document.getElementById(previewImgId);
            if (!previewImg) return;
        
            baseImage.onload = () => {
                URL.revokeObjectURL(baseImage.src); // Libérer l'ancienne URL d'objet
                canvas.width = baseImage.naturalWidth;
                canvas.height = baseImage.naturalHeight;
                annotations = JSON.parse(previewImg.dataset.annotations || '[]');
                setActiveTool('move');
                redrawCanvas();
                annotationModal.dataset.targetPreviewId = previewImgId;
                annotationModal.showModal();
            };
        
            baseImage.onerror = () => {
                alert("Impossible de charger l'image pour l'annotation.");
            };
        
            // Utiliser la src de l'image (qui est une URL d'objet)
            baseImage.src = previewImg.src;
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(baseImage, 0, 0);
            annotations.forEach(drawAnnotation);
            if (isDrawing && currentAnnotation) {
                drawAnnotation(currentAnnotation);
            }
            if (selectedAnnotation) {
                drawSelectionBorder(selectedAnnotation);
            }
        }

        function drawSelectionBorder(annotation) {
            ctx.save();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            let centerX, centerY;
            let x, y, width, height;

            if (annotation.type === 'location') {
                x = annotation.x - annotation.radius;
                y = annotation.y - annotation.radius;
                width = annotation.radius * 2;
                height = annotation.radius * 2;
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                x = annotation.x;
                y = annotation.y;
                width = annotation.width;
                height = annotation.height;
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                const minX = Math.min(annotation.startX, annotation.endX);
                const minY = Math.min(annotation.startY, annotation.endY);
                const maxX = Math.max(annotation.startX, annotation.endX);
                const maxY = Math.max(annotation.startY, annotation.endY);
                x = minX - 10;
                y = minY - 10;
                width = maxX - minX + 20;
                height = maxY - minY + 20;
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }
            
            ctx.strokeRect(x, y, width, height);
            ctx.restore();
        }

        function drawAnnotation(annotation) {
            ctx.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }

            if (annotation.rotation) {
                ctx.translate(centerX, centerY);
                ctx.rotate(annotation.rotation);
                ctx.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) {
                        ctx.restore();
                        return;
                    }
                    ctx.beginPath();
                    ctx.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`;
                    ctx.fill();
                    ctx.strokeStyle = '#5b9bd5';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    if (annotation.text) {
                        ctx.fillStyle = 'black';
                        ctx.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    drawArrow(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    ctx.strokeStyle = '#c0392b';
                    ctx.lineWidth = annotation.thickness || 5;
                    ctx.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            ctx.restore();
        }

        function drawArrow(fromx, fromy, tox, toy, lineWidth) {
            if (fromx === tox && fromy === toy) return;
            
            ctx.strokeStyle = '#c0392b';
            ctx.fillStyle = '#c0392b';
            ctx.lineWidth = lineWidth;
            
            const dx = tox - fromx;
            const dy = toy - fromy;
            const angle = Math.atan2(dy, dx);
            const headlen = Math.max(lineWidth * 3, 10); 
            const arrowLength = Math.sqrt(dx * dx + dy * dy);

            const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
            const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
            
            if (arrowLength < headlen * 1.5) {
                ctx.beginPath();
                ctx.moveTo(fromx, fromy);
                ctx.lineTo(tox, toy);
                ctx.stroke();
                return;
            }

            ctx.beginPath();
            ctx.moveTo(fromx, fromy);
            ctx.lineTo(lineToX, lineToY);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(tox, toy);
            ctx.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
            ctx.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
            ctx.closePath();
            ctx.fill();
        }

        function getEventPos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
            const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getRotatedPoint(x, y, centerX, centerY, angle) {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const translatedX = x - centerX;
            const translatedY = y - centerY;
            return {
                x: translatedX * cos - translatedY * sin + centerX,
                y: translatedX * sin + translatedY * cos + centerY
            };
        }

        function getAnnotationAtPosition(x, y) {
            for (let i = annotations.length - 1; i >= 0; i--) {
                const annotation = annotations[i];
                const angle = annotation.rotation || 0;
                let centerX, centerY;
                
                if (annotation.type === 'location') { centerX = annotation.x; centerY = annotation.y; } 
                else if (annotation.type === 'box') { centerX = annotation.x + annotation.width / 2; centerY = annotation.y + annotation.height / 2; } 
                else if (annotation.type === 'arrow') { centerX = (annotation.startX + annotation.endX) / 2; centerY = (annotation.startY + annotation.endY) / 2; }

                const rotatedPos = getRotatedPoint(x, y, centerX, centerY, angle);
                const testX = rotatedPos.x;
                const testY = rotatedPos.y;

                const tolerance = 15;
                let isInside = false;

                switch (annotation.type) {
                    case 'location':
                        isInside = Math.sqrt(Math.pow(testX - annotation.x, 2) + Math.pow(testY - annotation.y, 2)) <= annotation.radius + tolerance / 2;
                        break;
                    case 'box':
                        isInside = testX >= annotation.x - tolerance && testX <= annotation.x + annotation.width + tolerance &&
                            testY >= annotation.y - tolerance && testY <= annotation.y + annotation.height + tolerance;
                        break;
                    case 'arrow':
                        const dx = annotation.endX - annotation.startX;
                        const dy = annotation.endY - annotation.startY;
                        const lenSq = dx * dx + dy * dy;
                        if (lenSq === 0) break;
                        const t = ((testX - annotation.startX) * dx + (testY - annotation.startY) * dy) / lenSq;
                        const projX = annotation.startX + t * dx;
                        const projY = annotation.startY + t * dy;
                        if (t >= 0 && t <= 1) {
                            isInside = Math.pow(testX - projX, 2) + Math.pow(testY - projY, 2) <= Math.pow(annotation.thickness + tolerance, 2);
                        }
                        break;
                }

                if (isInside) return annotation;
            }
            return null;
        }

        function handleDrawStart(e) {
            e.preventDefault();
            const pos = getEventPos(canvas, e);
            startX = pos.x;
            startY = pos.y;
            if (currentTool === 'move') {
                selectedAnnotation = getAnnotationAtPosition(pos.x, pos.y);
                setContextualTools(selectedAnnotation);
                if (selectedAnnotation) {
                    isMovingAnnotation = true; 
                    document.body.style.overflow = 'hidden';
                    redrawCanvas(); 
                }
            } else {
                isDrawing = true;
                selectedAnnotation = null;
                setContextualTools(null);
                currentAnnotation = {
                    type: currentTool,
                    startX: startX,
                    startY: startY,
                    endX: startX,
                    endY: startY,
                    rotation: 0
                };
            }
        }

        function handleDrawMove(e) {
            e.preventDefault();
            if (!isDrawing && !isMovingAnnotation) return; 
            const pos = getEventPos(canvas, e);
            
            if (isMovingAnnotation && selectedAnnotation) {
                const deltaX = pos.x - startX;
                const deltaY = pos.y - startY;

                if (selectedAnnotation.type === 'arrow') {
                    selectedAnnotation.startX += deltaX;
                    selectedAnnotation.startY += deltaY;
                    selectedAnnotation.endX += deltaX;
                    selectedAnnotation.endY += deltaY;
                } else {
                    selectedAnnotation.x += deltaX;
                    selectedAnnotation.y += deltaY;
                }
                
                startX = pos.x;
                startY = pos.y;
                redrawCanvas();

            } else if (isDrawing && currentAnnotation) {
                currentAnnotation.endX = pos.x;
                currentAnnotation.endY = pos.y;
                redrawCanvas();
            }
        }

        function handleDrawEnd(e) {
            e.preventDefault();
            document.body.style.overflow = '';
            if (isMovingAnnotation) {
                isMovingAnnotation = false;
                redrawCanvas();
            } else if (isDrawing) {
                isDrawing = false;
                const final = { ...currentAnnotation };
                if (final.type === 'box') {
                    final.x = Math.min(final.startX, final.endX);
                    final.y = Math.min(final.startY, final.endY);
                    final.width = Math.abs(final.startX - final.endX);
                    final.height = Math.abs(final.startY - final.endY);
                    final.thickness = document.getElementById('box_thickness').value;
                    if (final.width < 5 || final.height < 5) return;
                } else if (final.type === 'arrow') {
                    final.thickness = document.getElementById('arrow_thickness').value;
                    if (Math.abs(final.startX - final.endX) < 5 && Math.abs(final.startY - final.endY) < 5) return;
                } else if (final.type === 'location') {
                    final.x = final.startX;
                    final.y = final.startY;
                    final.radius = Math.sqrt(Math.pow(final.endX - final.startX, 2) + Math.pow(final.endY - final.startY, 2));
                    final.text = document.getElementById('circle_text').value || 'Zone';
                    final.opacity = document.getElementById('circle_opacity').value;
                    if (final.radius < 5) return;
                }
                annotations.push(final);
                currentAnnotation = null;
                selectedAnnotation = final; 
                setContextualTools(selectedAnnotation);
                redrawCanvas();
            }
        }
        
        async function createAnnotatedImageBlob(imageBlob, annotationsData) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectURL = URL.createObjectURL(imageBlob);
                img.src = objectURL;
        
                img.onload = () => {
                    URL.revokeObjectURL(objectURL);
                    tempCanvas.width = img.naturalWidth;
                    tempCanvas.height = img.naturalHeight;
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(img, 0, 0);
        
                    annotationsData.forEach(annotation => drawAnnotationOnContext(tempCtx, img.naturalWidth, img.naturalHeight, annotation));
        
                    tempCanvas.toBlob(blob => {
                        if (blob) {
                            resolve(blob);
                        } else {
                            reject(new Error('La conversion du canevas en Blob a échoué.'));
                        }
                    }, 'image/png');
                };
        
                img.onerror = (e) => {
                    URL.revokeObjectURL(objectURL);
                    reject(new Error(`Impossible de charger l'image depuis le Blob : ${e.message}`));
                };
            });
        }
        
        function drawAnnotationOnContext(context, canvasWidth, canvasHeight, annotation) {
            context.save();
            let centerX, centerY;
            if (annotation.type === 'location') {
                centerX = annotation.x;
                centerY = annotation.y;
            } else if (annotation.type === 'box') {
                centerX = annotation.x + annotation.width / 2;
                centerY = annotation.y + annotation.height / 2;
            } else if (annotation.type === 'arrow') {
                centerX = (annotation.startX + annotation.endX) / 2;
                centerY = (annotation.startY + annotation.endY) / 2;
            }
            
            if (annotation.rotation) {
                context.translate(centerX, centerY);
                context.rotate(annotation.rotation);
                context.translate(-centerX, -centerY);
            }

            switch (annotation.type) {
                case 'location': {
                    const radius = annotation.radius || 0;
                    if (radius < 2) { context.restore(); return; }
                    context.beginPath(); context.arc(annotation.x, annotation.y, radius, 0, 2 * Math.PI);
                    context.fillStyle = `rgba(91, 155, 213, ${annotation.opacity || 0.5})`; context.fill();
                    context.strokeStyle = '#5b9bd5'; context.lineWidth = 2; context.stroke();
                    if (annotation.text) {
                        context.fillStyle = 'black'; context.font = `bold ${Math.max(12, radius / 2)}px Oswald`;
                        context.textAlign = 'center'; context.textBaseline = 'middle';
                        context.fillText(annotation.text, annotation.x, annotation.y);
                    }
                    break;
                }
                case 'arrow': {
                    const drawArrowLocal = (fromx, fromy, tox, toy, lineWidth) => {
                         if (fromx === tox && fromy === toy) return;
                         context.strokeStyle = '#c0392b'; context.fillStyle = '#c0392b'; context.lineWidth = lineWidth;
                         const headlen = Math.max(lineWidth * 3, 10); 
                         const dx = tox - fromx; const dy = toy - fromy;
                         const angle = Math.atan2(dy, dx);
                         const lineToX = tox - (headlen * 0.7) * Math.cos(angle);
                         const lineToY = toy - (headlen * 0.7) * Math.sin(angle);
                         
                         context.beginPath(); context.moveTo(fromx, fromy); context.lineTo(lineToX, lineToY); context.stroke();
                         context.beginPath(); context.moveTo(tox, toy);
                         context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 7), toy - headlen * Math.sin(angle - Math.PI / 7));
                         context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 7), toy - headlen * Math.sin(angle + Math.PI / 7));
                         context.closePath(); context.fill();
                    };
                    drawArrowLocal(annotation.startX, annotation.startY, annotation.endX, annotation.endY, annotation.thickness || 5);
                    break;
                }
                case 'box': {
                    context.strokeStyle = '#c0392b'; context.lineWidth = annotation.thickness || 5;
                    context.strokeRect(annotation.x, annotation.y, annotation.width, annotation.height);
                    break;
                }
            }
            context.restore();
        }

        function checkCoherence() {
            const dataString = localStorage.getItem('oiFormData');
            const formData = JSON.parse(dataString || '{}');
            const getVal = (id) => formData[id] || '';
            const alerts = [];
            const members = (formData.patracdvr_rows || []).flatMap(row => row.members);
            const indiaMembers = members.filter(m => m.cellule && m.cellule.toLowerCase().startsWith('india'));
            const aoMembers = members.filter(m => m.cellule && m.cellule.toLowerCase().startsWith('ao'));
            const allAssignedMembers = [...indiaMembers, ...aoMembers];

            if (!getVal('date_op')) { alerts.push("La **Date de l'opération** est manquante."); }

            if (!getVal('nom_adversaire')) { alerts.push("Le **Nom de l'adversaire** est manquant. (Onglet 2)"); }
            
            allAssignedMembers.forEach(member => {
                if (member.armement === 'Sans' && member.fonction !== 'Sans') {
                    alerts.push(`Membre **${member.trigramme}** est assigné mais n'a **AUCUN armement principal**. (Cellule: ${member.cellule})`);
                }
                if (member.fonction.toLowerCase() === 'effrac' && member.equipement !== 'EFFRAC') {
                    alerts.push(`Le membre **${member.trigramme}** (Effrac) n'a **PAS l'équipement EFFRAC** sélectionné.`);
                }
            });

            const chefInter = allAssignedMembers.find(m => m.fonction === 'Chef inter');
            if (chefInter && !chefInter.cellule.toLowerCase().startsWith('india')) {
                 alerts.push(`Le **Chef inter** (${chefInter.trigramme}) est assigné à la cellule **${chefInter.cellule}** au lieu d'India.`);
            }

            if (!formData.time_events || formData.time_events.length < 3) {
                alerts.push(`La **Chronologie** (T0, T1, T4...) est incomplète. Au moins 3 étapes sont recommandées. (Onglet 5)`);
            } else {
                 const t4 = formData.time_events.find(e => e.type === 'T4');
                 if (!t4) alerts.push("Le **TOP ACTION (T4)** n'est pas défini dans la chronologie.");
            }

            const unassignedCount = (formData.patracdvr_unassigned || []).length;
            if (unassignedCount > 0) {
                 alerts.push(`**${unassignedCount} membres** ne sont **PAS assignés** à un véhicule/équipe.`);
            }
            
            coherenceAlertsContainer.innerHTML = '';
            if (alerts.length > 0) {
                alerts.forEach(alertText => {
                    const alertDiv = document.createElement('div');
                    alertDiv.className = 'coherence-alert';
                    alertDiv.innerHTML = `<span class="material-symbols-outlined">warning</span> ${alertText.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}`;
                    coherenceAlertsContainer.appendChild(alertDiv);
                });
            } else {
                coherenceAlertsContainer.innerHTML = `<div class="coherence-alert" style="background-color: var(--success-green); color: white;"><span class="material-symbols-outlined">check_circle</span> Aucune incohérence majeure détectée. Prêt à générer.</div>`;
            }

            let recapHtml = '<h4>Synthèse des Éléments Clés :</h4><ul>';
            recapHtml += `<li>**Opération** du ${getVal('date_op') || 'N/A'} - H: ${getVal('heure_execution') || 'N/A'}</li>`;
            recapHtml += `<li>**Objectif** : ${getVal('nom_adversaire') || 'N/A'} (${getVal('domicile_adversaire').split('\n')[0] || 'N/A'})</li>`;
            recapHtml += `<li>**Équipe INDIA** : ${indiaMembers.map(m => m.trigramme).join(', ') || 'N/A'}</li>`;
            recapHtml += `<li>**Équipe AO** : ${aoMembers.map(m => m.trigramme).join(', ') || 'N/A'}</li>`;
            recapHtml += `<li>**Hypothèses** : H1 (${getVal('hypothese_h1').substring(0, 30)}...)</li>`;
            recapHtml += '</ul>';
            recapFinalisation.innerHTML = recapHtml;

            return alerts.length === 0;
        }


        document.addEventListener('DOMContentLoaded', async () => {
            
            try {
                await dbManager.init();
            } catch (e) {
                alert("Votre navigateur ne supporte pas IndexedDB, ou son utilisation est bloquée. La gestion des photos ne fonctionnera pas.");
                console.error(e);
                return;
            }
            
            const isLocalDataLoaded = await loadFormData();
            if (!isLocalDataLoaded) {
                 await loadDefaultConfig();
            }
            
            initChipContainer('etat_esprit_container', isLocalDataLoaded && JSON.parse(localStorage.getItem('oiFormData')).etat_esprit_list ? JSON.parse(localStorage.getItem('oiFormData')).etat_esprit_list : []);
            initChipContainer('volume_adversaire_container', isLocalDataLoaded && JSON.parse(localStorage.getItem('oiFormData')).volume_list ? JSON.parse(localStorage.getItem('oiFormData')).volume_list : []);

            setupQuickEditPanel(); 

            document.querySelector('.container').addEventListener('click', (event) => {
                const header = event.target.closest('.collapsible-header');
                if (header) { const container = header.parentElement; if (container && container.classList.contains('collapsible-container')) { container.classList.toggle('open'); } }
            });
            const modal = document.getElementById('editMemberModal'); const form = document.getElementById('editMemberForm');
            document.getElementById('modal_saveBtn').addEventListener('click', () => {
                const buttonId = form.dataset.editingButtonId; const button = document.getElementById(buttonId);
                if (button) {
                    button.dataset.trigramme = document.getElementById('modal_trigramme').value;
                    
                    for (const key in memberConfig) {
                        const attrName = key.replace(/s$/, '');
                        const selectId = 'modal_' + attrName;
                        const select = document.getElementById(selectId);
                        if (select) {
                            button.dataset[attrName] = select.value;
                        }
                    }
                    
                    updateMemberButtonVisuals(button);
                    populateQuickEditPanel(buttonId);
                    saveFormData();
                }
                modal.close();
            });
            document.getElementById('modal_cancelBtn').addEventListener('click', () => modal.close());
            
            document.getElementById('modal_deleteBtn').addEventListener('click', () => {
                const buttonId = form.dataset.editingButtonId; const button = document.getElementById(buttonId);
                const isUnassigned = button.closest('#unassigned_members_container');

                if (!button) return;

                if (isUnassigned) {
                    if(confirm(`Voulez-vous vraiment SUPPRIMER DÉFINITIVEMENT le membre ${button.dataset.trigramme || 'N/A'}? Cette action est irréversible.`)) {
                        button.remove(); 
                        saveFormData(); 
                        modal.close(); 
                        activeMemberId = null;
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                } else {
                    if(confirm(`Voulez-vous renvoyer le membre ${button.dataset.trigramme || 'N/A'} dans la section "Personnel à attribuer"?`)) {
                        button.dataset.cellule = 'Sans'; 
                        button.dataset.fonction = 'Sans'; 
                        updateMemberButtonVisuals(button);
                        unassignedContainer.appendChild(button);
                        saveFormData(); 
                        modal.close(); 
                        activeMemberId = null;
                        document.getElementById('quickEditPanel').style.display = 'none';
                    }
                }
            });
            
            const dockMenu = document.getElementById('dockMenu'); const dockToggleBtn = document.getElementById('dockToggleBtn');
            dockToggleBtn.addEventListener('click', (event) => { event.stopPropagation(); dockMenu.classList.toggle('collapsed'); localStorage.setItem('dockCollapsed', dockMenu.classList.contains('collapsed')); });
            document.getElementById('darkModeToggle').addEventListener('click', () => {
                document.body.classList.toggle('light-mode'); document.body.classList.toggle('dark-mode');
                const isDarkMode = document.body.classList.contains('dark-mode');
                localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
                document.getElementById('darkModeIcon').textContent = isDarkMode ? 'nightlight' : 'clear_day';
            });
            document.getElementById('settingsBtn').addEventListener('click', () => {
                const settingsModal = document.getElementById('settingsModal');
                document.getElementById('geminiApiKey').value = localStorage.getItem('geminiApiKey') || '';
                settingsModal.showModal();
            });
            document.getElementById('settings_closeBtn').addEventListener('click', () => {
                document.getElementById('settingsModal').close();
            });
            document.getElementById('settings_saveBtn').addEventListener('click', () => {
                const apiKey = document.getElementById('geminiApiKey').value;
                if (apiKey) {
                    localStorage.setItem('geminiApiKey', apiKey);
                    alert("Clé API sauvegardée.");
                    document.getElementById('settingsModal').close();
                } else {
                    alert("Veuillez saisir une clé API.");
                }
            });
            document.getElementById('resetBtn').addEventListener('click', async () => { 
                if (confirm("Voulez-vous vraiment réinitialiser tout le formulaire (y compris les photos) ?")) { 
                    localStorage.removeItem('oiFormData'); 
                    await dbManager.clearAllImages();
                    location.reload(); 
                } 
            });
            document.getElementById('tutorialBtn').addEventListener('click', startTutorial);
            
            importJsonConfigBtn.addEventListener('click', () => {
                 jsonConfigInput.click();
            });
            
            jsonConfigInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) { return; }
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const config = JSON.parse(e.target.result);
                        if (config && (Array.isArray(config.members) || config.options)) {
                            patracdvrContainer.innerHTML = ''; 
                            loadConfigObject(config); 
                        }
                        else { alert("Le fichier JSON est invalide ou ne contient pas de tableau 'members' ou d'objet 'options'."); }
                    } catch (err) { alert("Erreur de lecture du JSON."); console.error(err); }
                    location.reload(); 
                };
                reader.readAsText(file);
                event.target.value = null; 
            });

            importDefaultConfigBtn.addEventListener('click', () => {
                if(confirm("Ceci va remplacer la configuration PATRACDVR et les options d'équipement actuelles. Continuer?")) {
                    loadDefaultConfig();
                }
            });
            
            retexReportBtn.addEventListener('click', () => {
                 const dateOp = document.getElementById('date_op').value;
                 const nomAdversaire = document.getElementById('nom_adversaire').value;
                 if (!dateOp || !nomAdversaire) {
                    alert("Veuillez renseigner la date de l'opération et le nom de l'adversaire pour créer le lien RETEX.");
                    return;
                 }
                 const safeAdversaireName = nomAdversaire.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                 const oiId = `${dateOp}_${safeAdversaireName}`;
                 const retexUrl = `${RETEX_BASE_URL}?oiId=${encodeURIComponent(oiId)}`;
                 window.open(retexUrl, '_blank');
            });
            
            resetPatracdvrBtn.addEventListener('click', () => { 
                if (confirm("Voulez-vous vraiment effacer TOUS les véhicules et membres du PATRACDVR et vider la sauvegarde locale des membres ?")) { 
                    patracdvrContainer.innerHTML = ''; 
                    unassignedContainer.innerHTML = ''; 
                    localStorage.removeItem('oiFormData'); 
                    saveFormData(); 
                    alert("PATRACDVR réinitialisé. La prochaine fois, une configuration par défaut sera chargée (si disponible).");
                } 
            });
            
            const vehicleCreationContainer = document.getElementById('vehicle_creation_buttons');
            availableVehicles.forEach(vehicle => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'add-btn add-vehicle-btn';
                btn.textContent = `➕ ${vehicle}`;
                btn.addEventListener('click', () => addPatracdvrRow(vehicle));
                vehicleCreationContainer.insertBefore(btn, document.getElementById('addManualVehicleBtn'));
            });

            document.getElementById('addManualVehicleBtn').addEventListener('click', addManualVehicle);
            document.getElementById('addManualMemberBtn').addEventListener('click', addManualMember);

            document.querySelector('.wizard-step:has(#patracdvr_container)').addEventListener('click', handleMemberSelection);

            document.getElementById('quickEditPanel').addEventListener('click', (event) => {
                event.stopPropagation();
                const target = event.target;
                const quickEditButton = target.closest('.quick-edit-btn');
                const fullEditButton = target.closest('#fullEditBtn');

                if (quickEditButton && activeMemberId) {
                    const activeMember = document.getElementById(activeMemberId);
                    if (!activeMember) return;
                    const attribute = quickEditButton.dataset.attribute;
                    const value = quickEditButton.dataset.value;
                    activeMember.dataset[attribute] = value;
                    
                    if (attribute === 'cellule' && value === 'Sans') {
                        activeMember.dataset.fonction = 'Sans';
                    }
                    if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                        activeMember.dataset.cellule = 'India 1'; 
                    }
                    
                    updateMemberButtonVisuals(activeMember);
                    const group = quickEditButton.parentElement;
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                    quickEditButton.classList.add('selected');
                    saveFormData();
                } else if (fullEditButton && activeMemberId) {
                    openMemberModal(activeMemberId);
                }
            });

            const quickEditModal = document.getElementById('quickEditModal');
            document.getElementById('quick_modal_closeBtn').addEventListener('click', () => quickEditModal.close());
            quickEditModal.addEventListener('click', (event) => {
                const target = event.target.closest('.quick-edit-btn');
                if (!target || !activeMemberId) return;

                const activeMember = document.getElementById(activeMemberId);
                if (!activeMember) return;

                const attribute = target.dataset.attribute;
                const value = target.dataset.value;

                activeMember.dataset[attribute] = value;
                
                if (attribute === 'cellule' && value === 'Sans') {
                    activeMember.dataset.fonction = 'Sans';
                }
                if (attribute === 'fonction' && value !== 'Sans' && activeMember.dataset.cellule === 'Sans') {
                    activeMember.dataset.cellule = 'India 1';
                }
                
                updateMemberButtonVisuals(activeMember);
                
                const group = target.closest('.quick-edit-options');
                if(group) {
                    group.querySelectorAll('.quick-edit-btn').forEach(btn => btn.classList.remove('selected'));
                }
                target.classList.add('selected');

                saveFormData();
            });


            canvas.addEventListener('mousedown', handleDrawStart); canvas.addEventListener('mousemove', handleDrawMove);
            canvas.addEventListener('mouseup', handleDrawEnd); canvas.addEventListener('mouseout', handleDrawEnd);
            canvas.addEventListener('touchstart', handleDrawStart, { passive: false }); 
            canvas.addEventListener('touchmove', handleDrawMove, { passive: false });
            canvas.addEventListener('touchend', handleDrawEnd);
            
            document.querySelectorAll('.toolbar-main-tools .tool-btn').forEach(btn => {
                btn.addEventListener('click', () => { const toolId = btn.id.split('_')[1]; if (['move', 'location', 'arrow', 'box'].includes(toolId)) setActiveTool(toolId); });
            });
            document.getElementById('tool_reset').addEventListener('click', () => { annotations = []; selectedAnnotation = null; setContextualTools(null); redrawCanvas();});
            document.getElementById('annotation_cancel').addEventListener('click', () => annotationModal.close());
            document.getElementById('annotation_save').addEventListener('click', () => {
                const targetId = annotationModal.dataset.targetPreviewId; 
                const previewImg = document.getElementById(targetId);
                if(previewImg) {
                    previewImg.dataset.annotations = JSON.stringify(annotations);
                }
                saveFormData(); 
                annotationModal.close();
            });
            
            rotationInput.addEventListener('change', updateAnnotationRotation);

            document.getElementById('delete_btn').addEventListener('click', () => { if(selectedAnnotation){ annotations = annotations.filter(ann => ann !== selectedAnnotation); selectedAnnotation = null; setContextualTools(null); redrawCanvas(); } });
            document.getElementById('edit_text_btn').addEventListener('click', () => { if(selectedAnnotation && selectedAnnotation.type === 'location'){ const newText = prompt('Modifier texte:', selectedAnnotation.text); if(newText !== null){ selectedAnnotation.text = newText; redrawCanvas(); } } });
            
            const importSessionBtn = document.getElementById('importSessionBtn');
            const exportSessionBtn = document.getElementById('exportSessionBtn');
            const sessionFileInput = document.getElementById('sessionFileInput');
            importSessionBtn.addEventListener('click', () => sessionFileInput.click());
            exportSessionBtn.addEventListener('click', () => {
                saveFormData();
                const dataString = localStorage.getItem('oiFormData');
                if (!dataString) { alert("Aucune donnée à exporter."); return; }
                const blob = new Blob([dataString], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                const date = new Date().toISOString().slice(0, 10);
                link.download = `OI_Session_${date}.json`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            });
            sessionFileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const jsonContent = e.target.result;
                        JSON.parse(jsonContent); 
                        
                        await dbManager.clearAllImages();
                        localStorage.setItem('oiFormData', jsonContent);
                        
                        alert("Session importée. Attention : les images ne sont pas incluses dans l'export/import de session. Vous devrez les rajouter manuellement.");
                        location.reload();
                    } catch (err) {
                        alert("Fichier invalide ou corrompu.");
                    }
                };
                reader.readAsText(file);
                event.target.value = null;
            });

            document.addEventListener('dragstart', e => { 
                const target = e.target.closest('.patracdvr-member-btn, .time-item');
                if (target && target.classList.contains('draggable')) { 
                    draggedItem = target; 
                    e.dataTransfer.setData('text/plain', target.id);
                    setTimeout(() => target.classList.add('dragging'), 0); 
                } 
            });

            document.addEventListener('dragend', () => { 
                if (draggedItem) { 
                    draggedItem.classList.remove('dragging'); 
                    draggedItem = null; 
                } 
            });

            const dropContainers = document.querySelectorAll('.patracdvr-members-container, #unassigned_members_container');
            dropContainers.forEach(container => {
                container.addEventListener('dragenter', handleDragEnter);
                container.addEventListener('dragleave', handleDragLeave);
                container.addEventListener('dragover', handleDragOver); 
                container.addEventListener('drop', handleDrop);
            });

            document.addEventListener('dragover', e => {
                e.preventDefault();
                const targetContainer = e.target.closest('#time_events_container');
                if (targetContainer && draggedItem && draggedItem.classList.contains('time-item')) {
                    const afterElement = getDragAfterElement(targetContainer, e.clientY);
                    if (afterElement == null) { targetContainer.appendChild(draggedItem); } 
                    else { targetContainer.insertBefore(draggedItem, afterElement); }
                }
            });
            
            async function downloadOiPdf() {
                if (typeof PDFLib === 'undefined') { alert("Erreur: La bibliothèque PDF n'est pas encore chargée."); return; }
                const btn = downloadPdfBtn;
                const originalText = btn.textContent;
                btn.textContent = 'Génération en cours...'; btn.disabled = true;
                
                try {
                    const result = await buildPdf();
                    if (!result) { 
                        alert("La génération a échoué. Vérifiez vos données.");
                        return; 
                    }
                    const { pdfBytes, formData } = result;
                    const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                    const url = URL.createObjectURL(blob);
                    
                    const getVal = (id) => formData[id] || 'RAS';
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `OI_${getVal('date_op').replace(/[\/\\?%*:|"<>]/g, '-')}_${getVal('nom_adversaire').replace(/ /g, '_')}.pdf`;
                    document.body.appendChild(link); 
                    link.click(); 
                    document.body.removeChild(link);
                    
                    alert("Le document PDF a été téléchargé.");
                    
                } catch (error) {
                    console.error("Erreur critique lors de la génération du PDF:", error);
                    alert("Une erreur critique est survenue lors de la génération du PDF. Consultez la console (F12).");
                } finally {
                    btn.textContent = originalText; btn.disabled = false;
                }
            }

            function openPresentationMode() {
                const presentationContent = document.getElementById('presentation-content');
                
                if (!presentationModal) {
                    console.error("Modale 'presentationModal' non trouvée.");
                    return;
                }

                if(!checkCoherence()) {
                     alert("Attention: Des incohérences ont été détectées. Veuillez les vérifier dans la section Finalisation avant de générer.");
                }

                presentationContent.innerHTML = '<h2>Chargement de l\'aperçu...</h2><p style="text-align:center;">Veuillez patienter pendant la compilation des images annotées.</p>';

                if(typeof presentationModal.showModal === 'function') {
                    presentationModal.showModal();
                } else {
                    presentationModal.style.display = 'block';
                }
                
                buildPresentationHtml().then(html => {
                    presentationContent.innerHTML = html;
                }).catch(err => {
                    console.error("Erreur lors de la construction de l'aperçu HTML:", err);
                    const dangerColor = document.body.classList.contains('dark-mode') ? '#c0392b' : '#c0392b';
                    presentationContent.innerHTML = '<h2>Erreur d\'affichage</h2><p style="color:' + dangerColor + ';">Une erreur est survenue lors de la compilation des images annotées pour l\'aperçu. Réessayez ou vérifiez la console.</p>';
                });
            }

            previewBtn.addEventListener('click', openPresentationMode);
            downloadPdfBtn.addEventListener('click', downloadOiPdf);

            if (document.getElementById('closePresentationModalBtn')) {
                document.getElementById('closePresentationModalBtn').addEventListener('click', () => {
                    if (presentationModal) {
                         if(typeof presentationModal.close === 'function') {
                            presentationModal.close();
                        } else {
                            presentationModal.style.display = 'none';
                        }
                    }
                });
            }


            retexFileInput.addEventListener('change', (event) => {
                const files = event.target.files;
                let fileNames = [];
                
                if (files.length === 0) {
                    retexFileNames.textContent = 'Aucun fichier sélectionné';
                    retexStatus.textContent = '';
                    generateRetexPdfBtn.style.display = 'none';
                    return;
                }
                
                fileNames = Array.from(files).map(f => f.name);
                retexFileNames.textContent = fileNames.join(', ');
                retexStatus.textContent = `${fileNames.length} fichier(s) sélectionné(s). Prêt pour l'analyse.`;
                retexOutput.style.display = 'none';
            });

            async function generateGeminiAnalysis(reports) {
                const apiKey = localStorage.getItem('geminiApiKey');
                if (!apiKey) {
                    retexStatus.textContent = "Erreur: Clé API Gemini non configurée. Allez dans Paramètres.";
                    return null;
                }
                
                const formattedReports = reports.map(report => JSON.stringify(report, null, 2)).join('\n\n--- Rapport suivant ---\n\n');

                const prompt = `
                Tu es un analyste tactique de la Gendarmerie Française.
                Ton rôle est de synthétiser des rapports de retour d'expérience (RETEX) suite à des opérations de police judiciaire.
                L'objectif est de produire une analyse impartiale et objective, en te basant uniquement sur les faits rapportés, sans émettre de jugement personnel.

                **Tâche:**
                Prends en compte les comptes-rendus RETEX fournis ci-dessous.
                Identifie les points clés et les enseignements à tirer de l'opération.
                Classe et structure ta synthèse en trois sections principales, chacune avec des sous-sections claires:
                1.  **Points Forts:** Ce qui a bien fonctionné.
                    * Coordination:
                    * Matériel/Équipement:
                    * Tactique:
                2.  **Points Faibles:** Ce qui a posé problème.
                    * Communication:
                    * Préparation:
                    * Exécution:
                3.  **Axe d'Amélioration:** Recommandations concrètes et concises pour de futures opérations.
                    * Formation:
                    * Procédure:
                    * Équipement:

                **Contenu des rapports RETEX:**
                ${formattedReports}

                **Format de la réponse:**
                Utilise le format Markdown pour ta réponse. Respecte scrupuleusement les en-têtes et sous-en-têtes demandés.
                Ne te base que sur les informations que je te donne et ne spécule pas sur des éléments extérieurs.
                S'il n'y a pas d'informations pour une section, écris "RAS" (Rien À Signaler).
                Reste professionnel et factuel. N'utilise pas de phrases trop longues.
                Commence ta réponse par "### Rapport d'Analyse Opérationnelle".
                `;

                try {
                    retexStatus.textContent = "Analyse en cours par l'IA...";
                    const response = await fetch(`${GEMINI_API_URL}?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Erreur API: ${response.status} - ${JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    const textOutput = data?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (textOutput) {
                        retexStatus.textContent = "Analyse terminée.";
                        return marked.parse(textOutput);
                    } else {
                        retexStatus.textContent = "Analyse terminée, mais aucune réponse significative n'a été reçue.";
                        return "<p>Aucune réponse significative de l'IA.</p>";
                    }
                } catch (error) {
                    console.error("Erreur lors de la génération de l'analyse:", error);
                    retexStatus.textContent = `Erreur: ${error.message}`;
                    return null;
                }
            }

            async function generateRetexPdf() {
                if (typeof window.jspdf === 'undefined' || typeof window.html2canvas === 'undefined') {
                    alert("Erreur: Les bibliothèques de génération PDF ne sont pas chargées.");
                    return;
                }
                const btn = generateRetexPdfBtn;
                const originalText = btn.textContent;
                btn.textContent = 'Génération PDF en cours...'; 
                btn.disabled = true;

                try {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF('p', 'pt', 'a4', true);
                    const content = document.getElementById('retex_output');
                    
                    const originalDisplay = content.style.display;
                    content.style.display = 'block';

                    const canvas = await html2canvas(content, {
                        scale: 2, 
                        logging: false,
                        useCORS: true
                    });

                    content.style.display = originalDisplay; 

                    const imgData = canvas.toDataURL('image/jpeg', 1.0);
                    const imgWidth = 550; 
                    const pageHeight = 842; 
                    const imgHeight = canvas.height * imgWidth / canvas.width;
                    let heightLeft = imgHeight;

                    let position = 0; 
                    const margin = 20;

                    doc.addImage(imgData, 'JPEG', margin, margin, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        doc.addPage();
                        doc.addImage(imgData, 'JPEG', margin, position + margin, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    doc.save('Rapport_Retex.pdf');
                    retexStatus.textContent = 'Rapport PDF généré et téléchargé.';

                } catch (error) {
                    console.error("Erreur lors de la génération du PDF RETEX:", error);
                    alert("Une erreur est survenue lors de la génération du PDF du rapport. Consultez la console (F12).");
                } finally {
                    btn.textContent = originalText;
                    btn.disabled = false;
                }
            }

            launchRetexAnalysisBtn.addEventListener('click', async (event) => {
                event.preventDefault(); 
                
                const files = retexFileInput.files;
                if (files.length === 0) {
                    retexStatus.textContent = "Veuillez sélectionner au moins un fichier JSON.";
                    return;
                }
                retexOutput.innerHTML = '';
                retexOutput.style.display = 'none';
                generateRetexPdfBtn.style.display = 'none';
                retexStatus.textContent = 'Lecture et analyse des fichiers en cours...';

                let allReports = [];
                const promises = Array.from(files).map(file => {
                    return new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const jsonData = JSON.parse(e.target.result);
                                allReports.push(jsonData);
                            } catch (error) {
                                console.error(`Erreur de lecture du fichier ${file.name}:`, error);
                            }
                            resolve();
                        };
                        reader.onerror = (e) => {
                            console.error(`Erreur de lecture du fichier ${file.name}:`, e);
                            resolve(); 
                        }
                        reader.readAsText(file);
                    });
                });

                try {
                    await Promise.all(promises);

                    if (allReports.length > 0) {
                        const htmlOutput = await generateGeminiAnalysis(allReports);
                        
                        if (htmlOutput) {
                            retexOutput.innerHTML = htmlOutput;
                            retexOutput.style.display = 'block';
                            generateRetexPdfBtn.style.display = 'inline-block';
                            retexStatus.textContent = `Analyse terminée. ${allReports.length} rapport(s) traité(s).`;
                        } else {
                            retexOutput.innerHTML = "<p>Impossible de générer le rapport. Veuillez vérifier la console pour plus de détails.</p>";
                        }
                    } else {
                        retexStatus.textContent = "Erreur: Aucun rapport JSON valide n'a pu être chargé.";
                        retexOutput.innerHTML = '';
                    }
                } catch (error) {
                    retexStatus.textContent = `Erreur critique: ${error.message}`;
                    console.error("Erreur générale lors du processus d'analyse:", error);
                }
            });

            generateRetexPdfBtn.addEventListener('click', generateRetexPdf);


            if (localStorage.getItem('theme') === 'light') { document.body.classList.replace('dark-mode', 'light-mode'); document.getElementById('darkModeIcon').textContent = 'clear_day'; }
            if (localStorage.getItem('dockCollapsed') === 'true') { dockMenu.classList.add('collapsed'); }
            
            showStep(currentStep);
            
        });
        
        // --- PDF GENERATION LOGIC ---

        function getAdversaryImageInfo(formData) {
            const mainPhotoContainerId = 'adversary_photo_preview_container';
            if (formData.dynamic_photos && formData.dynamic_photos[mainPhotoContainerId]) {
                const firstImage = formData.dynamic_photos[mainPhotoContainerId][0];
                if (firstImage) {
                    return {
                        id: firstImage.id,
                        annotationsJson: firstImage.annotations || '[]'
                    };
                }
            }
            return null;
        }

        async function compressImage(imageBlob, quality) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const objectURL = URL.createObjectURL(imageBlob);
                img.src = objectURL;
        
                img.onload = () => {
                    URL.revokeObjectURL(objectURL);
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
        
                    const MAX_DIMENSION = 1920;
                    let { naturalWidth: width, naturalHeight: height } = img;
                    if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                        if (width > height) {
                            height = (MAX_DIMENSION / width) * height;
                            width = MAX_DIMENSION;
                        } else {
                            width = (MAX_DIMENSION / height) * width;
                            height = MAX_DIMENSION;
                        }
                    }
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
        
                    canvas.toBlob(
                        (blob) => {
                            if (blob) {
                                resolve(blob.arrayBuffer());
                            } else {
                                reject(new Error('La conversion du canevas en Blob a échoué.'));
                            }
                        },
                        'image/jpeg',
                        quality
                    );
                };
                img.onerror = () => {
                    URL.revokeObjectURL(objectURL);
                    reject(new Error("Échec du chargement du Blob de l'image dans l'élément Image."));
                };
            });
        }

        async function buildPdf() {
            const { PDFDocument, StandardFonts, rgb, PageSizes } = PDFLib;
            const pdfDoc = await PDFDocument.create();
            let helveticaFont, helveticaBoldFont;
            try {
                helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
                helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
            } catch (e) {
                console.error("Erreur de chargement des polices PDF standard:", e);
                return null;
            }
        
            saveFormData();
            const formDataString = localStorage.getItem('oiFormData');
            if (!formDataString) { alert("Aucune donnée à générer."); return null; }
            const formData = JSON.parse(formDataString);
        
            // --- Section de Compression Dynamique ---
            const PDF_TARGET_SIZE_BYTES = 2.5 * 1024 * 1024;
            const TEXT_OVERHEAD_ESTIMATE = 150 * 1024; // 150KB pour le texte et la structure PDF
            
            const allImagesMeta = [];
            if (formData.dynamic_photos) {
                for (const category in formData.dynamic_photos) {
                    formData.dynamic_photos[category].forEach(imgMeta => allImagesMeta.push(imgMeta));
                }
            }
        
            let quality = 0.9;
            const minQuality = 0.5;
            let compressedImages = {};
            let totalImageSize = 0;
        
            if (allImagesMeta.length > 0) {
                console.log("Début de la compression dynamique...");
                do {
                    totalImageSize = 0;
                    const compressionPromises = allImagesMeta.map(async (imgMeta) => {
                        const originalBlob = await dbManager.getImage(imgMeta.id);
                        if (!originalBlob) return { id: imgMeta.id, buffer: null };
                        
                        const annotations = JSON.parse(imgMeta.annotations || '[]');
                        let blobToCompress = originalBlob;
                        if (annotations.length > 0) {
                            blobToCompress = await createAnnotatedImageBlob(originalBlob, annotations);
                        }
                        
                        const compressedBuffer = await compressImage(blobToCompress, quality);
                        return { id: imgMeta.id, buffer: compressedBuffer };
                    });
                    
                    const results = await Promise.all(compressionPromises);
                    
                    compressedImages = {};
                    for (const result of results) {
                        if (result.buffer) {
                            compressedImages[result.id] = result.buffer;
                            totalImageSize += result.buffer.byteLength;
                        }
                    }
                    
                    console.log(`Qualité: ${quality.toFixed(1)}, Taille totale des images: ${(totalImageSize / 1024 / 1024).toFixed(2)}MB`);
                    
                    if (totalImageSize + TEXT_OVERHEAD_ESTIMATE < PDF_TARGET_SIZE_BYTES) {
                        break; 
                    }
                    
                    quality -= 0.1; 
                    
                } while (quality >= minQuality);

                if (totalImageSize + TEXT_OVERHEAD_ESTIMATE > PDF_TARGET_SIZE_BYTES) {
                    alert(`Avertissement: Le PDF généré pourrait dépasser 2.5Mo. La taille des images compressées est de ${(totalImageSize / 1024 / 1024).toFixed(2)}MB.`);
                }
            }
            // --- Fin de la Section de Compression ---

            const getVal = (id) => formData[id] || '';
            const isDarkMode = document.body.classList.contains('dark-mode');
            const context = {
                pdfDoc, helveticaFont, helveticaBoldFont,
                currentPage: null, y: 0, pageWidth: 0, pageHeight: 0, margin: 40,
                colors: isDarkMode ? { background: rgb(30/255, 30/255, 30/255), text: rgb(1, 1, 1), accent: rgb(91/255, 155/255, 213/255), danger: rgb(192/255, 57/255, 43/255) } : { background: rgb(1, 1, 1), text: rgb(0, 0, 0), accent: rgb(0, 51/255, 160/255), danger: rgb(192/255, 57/255, 43/255) }
            };
            let backgroundImage = null;
            try {
                const bgImageUrl = 'Fd.png';
                const bgImageBytes = await fetch(bgImageUrl).then(res => res.arrayBuffer());
                backgroundImage = await pdfDoc.embedPng(bgImageBytes);
            } catch (e) { console.warn("L'image de fond 'Fd.png' n'a pas pu être chargée.", e); }
            
            const addNewPage = () => {
                context.currentPage = context.pdfDoc.addPage([PageSizes.A4[1], PageSizes.A4[0]]);
                const { width, height } = context.currentPage.getSize();
                context.pageWidth = width; context.pageHeight = height; context.y = height - context.margin;
                context.currentPage.drawRectangle({ x: 0, y: 0, width, height, color: context.colors.background });
            };
            const checkY = (spaceNeeded) => { if (context.y - spaceNeeded < context.margin) { addNewPage(); return true; } return false; };
            const drawTitle = (text) => { checkY(30); context.currentPage.drawText(text, { x: context.margin, y: context.y, font: helveticaBoldFont, size: 18, color: context.colors.accent }); context.y -= 30; };
            const drawSubTitle = (text) => { if (checkY(25)) { context.y -= 10; } context.currentPage.drawText(text, { x: context.margin, y: context.y, font: helveticaBoldFont, size: 14, color: context.colors.accent }); context.y -= 25; };
            const wrapText = (text, font, size, maxWidth) => {
                const words = String(text || '').replace(/\n/g, ' \n ').split(' ');
                let lines = []; let currentLine = '';
                for (const word of words) {
                    if (word === '\n') { lines.push(currentLine); currentLine = ''; continue; }
                    const lineWithWord = currentLine === '' ? word : `${currentLine} ${word}`;
                    if (font.widthOfTextAtSize(lineWithWord, size) > maxWidth && currentLine !== '') { lines.push(currentLine); currentLine = word; } 
                    else { currentLine = lineWithWord; }
                }
                lines.push(currentLine); return lines;
            };
            const drawWrappedText = (text, options = {}) => {
                const { font = helveticaFont, size = 12, color = context.colors.text, x = context.margin + 15 } = options;
                const maxWidth = context.pageWidth - x - context.margin;
                const lines = wrapText(text, font, size, maxWidth);
                const totalHeight = lines.length * (size + 4);
                if (checkY(totalHeight + 10)) { context.y -= (size + 4); }
                lines.forEach((line, index) => { context.currentPage.drawText(line, { x, y: context.y - (index * (size + 4)), font, size, color }); });
                context.y -= (totalHeight + 10);
            };
            const drawTable = (headers, rows, columnWidths, startX) => {
                let currentY = context.y; const rowPadding = 5; const headerFontSize = 10; const contentFontSize = 10;
                const drawRow = (rowData, isHeader) => {
                    const font = isHeader ? helveticaBoldFont : helveticaFont; const size = isHeader ? headerFontSize : contentFontSize;
                    const cellContents = rowData.map((text, i) => wrapText(text, font, size, columnWidths[i] - 2 * rowPadding));
                    const maxLines = Math.max(...cellContents.map(lines => lines.length));
                    const rowHeight = maxLines * (size + 2) + 2 * rowPadding;
                    if (currentY - rowHeight < context.margin) { addNewPage(); currentY = context.y; drawRow(headers, true); }
                    currentY -= rowHeight; let currentX = startX;
                    rowData.forEach((_, i) => {
                        context.currentPage.drawRectangle({ x: currentX, y: currentY, width: columnWidths[i], height: rowHeight, borderColor: context.colors.accent, borderWidth: 0.5 });
                        const lines = cellContents[i];
                        lines.forEach((line, lineIndex) => { context.currentPage.drawText(line, { x: currentX + rowPadding, y: currentY + rowHeight - rowPadding - (lineIndex + 1) * (size + 2) + 2, font, size, color: context.colors.text }); });
                        currentX += columnWidths[i];
                    });
                };
                drawRow(headers, true); rows.forEach(row => drawRow(row, false)); context.y = currentY - 20;
            };
            
            const drawImagesFromCategory = async (previewContainerId, title) => {
                const imagesData = (formData.dynamic_photos || {})[previewContainerId] || [];
                for (let i = 0; i < imagesData.length; i++) {
                    const imgData = imagesData[i];
                    addNewPage();
                    try {
                        const imageBytes = compressedImages[imgData.id];
                        if (!imageBytes) throw new Error("Données d'image compressées non trouvées.");

                        let image;
                        try {
                            image = await pdfDoc.embedJpg(imageBytes);
                        } catch (e) {
                            console.warn("Échec de l'intégration en tant que JPEG, tentative en PNG...", e);
                            image = await pdfDoc.embedPng(imageBytes);
                        }
                        
                        const { width, height } = context.currentPage.getSize();
                        const paddedW = width - context.margin * 2; const paddedH = height - context.margin * 2 - 30;
                        const scaled = image.scaleToFit(paddedW, paddedH);
                        const x = (width - scaled.width) / 2; const y = (height - scaled.height) / 2 + 15;
                        context.currentPage.drawImage(image, { x, y, width: scaled.width, height: scaled.height });
                        const finalTitle = imagesData.length > 1 ? `${title} (${i+1})` : title;
                        const textWidth = helveticaBoldFont.widthOfTextAtSize(finalTitle, 14);
                        context.currentPage.drawText(finalTitle, { x: width / 2 - textWidth / 2, y: y - 20, font: helveticaBoldFont, size: 14, color: context.colors.text });
                    } catch (e) {
                        console.error(`Erreur d'intégration de l'image pour: ${title}`, e);
                        drawTitle("Erreur d'image"); drawWrappedText(`Impossible de charger une image.\n\nErreur: ${e.message}`);
                    }
                }
            };
            
            const getCompositionData = (teamPrefix) => {
                const membersByCell = {};
                const allMembers = (formData.patracdvr_rows || []).flatMap(row => row.members);
                
                allMembers.forEach(member => {
                    if (member.cellule && member.cellule.toLowerCase().startsWith(teamPrefix)) {
                        if (!membersByCell[member.cellule]) membersByCell[member.cellule] = [];
                        member.trigramme && membersByCell[member.cellule].push(member.trigramme);
                    }
                });

                const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                const sortedKeys = Object.keys(membersByCell).sort(naturalSort);
                
                return sortedKeys.map(cell => ({ cell: cell, members: membersByCell[cell] }));
            };

            const drawCompositionList = (compositionData) => {
                const fontSize = 12;
                const lineHeight = fontSize + 4;
                if (checkY(lineHeight)) { context.y -= 10; }

                let currentX = context.margin + 15;
                const cellStyle = { font: helveticaBoldFont, color: context.colors.danger, size: fontSize };
                const trigrammeStyle = { font: helveticaBoldFont, color: context.colors.text, size: fontSize };
                const separatorStyle = { font: helveticaFont, color: context.colors.text, size: fontSize };
                
                compositionData.forEach((group, groupIndex) => {
                    const cellShortName = group.cell.toLowerCase().replace('india ', 'I').replace('ao', 'AO').toUpperCase();
                    
                    const groupParts = [{ text: cellShortName, style: cellStyle }, { text: ' : ', style: separatorStyle }];
                    group.members.forEach((member, memberIndex) => {
                        groupParts.push({ text: member, style: trigrammeStyle });
                        if (memberIndex < group.members.length - 1) {
                            groupParts.push({ text: ' - ', style: separatorStyle });
                        }
                    });
                     if (groupIndex < compositionData.length - 1) {
                        groupParts.push({ text: '    ', style: separatorStyle });
                    }

                    for(const part of groupParts) {
                        const partWidth = part.style.font.widthOfTextAtSize(part.text, part.style.size);
                        if (currentX + partWidth > context.pageWidth - context.margin) {
                            context.y -= lineHeight;
                            currentX = context.margin + 15;
                            if (checkY(lineHeight)) { context.y -= 10; }
                        }
                        context.currentPage.drawText(part.text, { x: currentX, y: context.y, ...part.style });
                        currentX += partWidth;
                    }
                });
                context.y -= (lineHeight + 10);
            };


            const pdfCreationLogic = async () => {
                addNewPage();
                if (backgroundImage) { context.currentPage.drawImage(backgroundImage, { x: 0, y: 0, width: context.pageWidth, height: context.pageHeight }); }
                const mainTitle = "OPÉRATION DE POLICE JUDICIAIRE";
                const dateTitle = `DU ${getVal('date_op') || '(DATE)'}`;
                const titleWidth = helveticaBoldFont.widthOfTextAtSize(mainTitle, 24);
                const dateTitleWidth = helveticaBoldFont.widthOfTextAtSize(dateTitle, 18);
                context.currentPage.drawText(mainTitle, { x: context.pageWidth / 2 - titleWidth / 2, y: context.pageHeight / 2 + 10, font: helveticaBoldFont, size: 24, color: context.colors.accent });
                context.currentPage.drawText(dateTitle, { x: context.pageWidth / 2 - dateTitleWidth / 2, y: context.pageHeight / 2 - 20, font: helveticaBoldFont, size: 18, color: context.colors.text });

                addNewPage();
                drawTitle("1. SITUATION");
                drawSubTitle("1.1 Situation Générale"); drawWrappedText(getVal('situation_generale'), { size: 14 });
                drawSubTitle("1.2 Situation Particulière"); drawWrappedText(getVal('situation_particuliere'), { size: 14 });
                
                addNewPage();
                drawTitle("2. ADVERSAIRE");
      
                const imageInfo = getAdversaryImageInfo(formData);
                let isImagePresent = imageInfo !== null;
                const photoBoxWidth = 200;
                const photoBoxHeight = 220;
                const photoBoxX = context.pageWidth - context.margin - photoBoxWidth;
                const photoBoxMargin = 10;
                const topY = context.y; 
                
                let tableStartX = context.margin;
                let tableMaxWidth = context.pageWidth - context.margin * 2;
                
                if (isImagePresent) {
                    tableMaxWidth = photoBoxX - tableStartX - photoBoxMargin;
                }
                
                const adversaireHeaders = ["Information", "Détail"];
                const meText = (formData.me_list || []).map((me, i) => `ME${i+1}: ${me}`).join(' | ');
                const adversaireRows = [
                    ['Nom/Prénom', getVal('nom_adversaire')], ['Domicile', getVal('domicile_adversaire')],
                    ['Naissance', `${getVal('date_naissance')} à ${getVal('lieu_naissance')}`],
                    ['Description', `${getVal('stature_adversaire')} / ${getVal('ethnie_adversaire')}`],
                    ['Signes particuliers', getVal('signes_particuliers')], ['Profession', getVal('profession_adversaire')],
                    ['Antécédents', getVal('antecedents_adversaire')], ['État d\'esprit', (formData.etat_esprit_list || []).join(', ')],
                    ['Attitude', getVal('attitude_adversaire')], ['Volume (renfort)', (formData.volume_list || []).join(', ')],
                    ['Substances', getVal('substances_adversaire')], ['Véhicules', (formData.vehicules_list || []).join(', ')],
                    ['Armes', getVal('armes_connues')], ['Moyens Employés', meText],
                ].filter(row => row[1] && String(row[1]).trim() !== 'à');
                
                let photoBottomY = topY;
                let tableBottomY = topY;
                
                if (isImagePresent) {
                    const { id } = imageInfo;
                    const frameY = topY - photoBoxHeight; 
                    
                    try {
                        const imageBytes = compressedImages[id];
                        if (!imageBytes) throw new Error("Données d'image compressées pour l'adversaire non trouvées.");

                        let image;
                        try {
                            image = await pdfDoc.embedJpg(imageBytes);
                        } catch (e) {
                            image = await pdfDoc.embedPng(imageBytes);
                        }
                        
                        const scaled = image.scaleToFit(photoBoxWidth - 10, photoBoxHeight - 30);
                        const imageY = frameY + (photoBoxHeight - scaled.height) / 2;

                        if(frameY >= context.margin) {
                            context.currentPage.drawRectangle({
                                x: photoBoxX, y: frameY, width: photoBoxWidth, height: photoBoxHeight,
                                borderColor: context.colors.accent, borderWidth: 1
                            });
                            context.currentPage.drawImage(image, {
                                x: photoBoxX + (photoBoxWidth - scaled.width) / 2,
                                y: imageY,
                                width: scaled.width, height: scaled.height
                            });
                            const photoTitle = "Photo de l'objectif";
                            const titleWidth = helveticaFont.widthOfTextAtSize(photoTitle, 10);
                            context.currentPage.drawText(photoTitle, {
                                x: photoBoxX + (photoBoxWidth - titleWidth) / 2,
                                y: frameY + 5,
                                font: helveticaFont, size: 10, color: context.colors.text
                            });
                            photoBottomY = frameY;
                        } else {
                            isImagePresent = false; 
                        }
                    } catch (e) {
                         console.error("Échec du traitement de la photo de l'adversaire :", e);
                        isImagePresent = false; 
                    }
                }

                if (adversaireRows.length > 0) {
                    context.y = topY; 
                    drawTable(adversaireHeaders, adversaireRows, [150, tableMaxWidth - 150], tableStartX);
                    tableBottomY = context.y;
                } else {
                    tableBottomY = topY;
                }
                
                context.y = Math.min(tableBottomY, photoBottomY) - 20;
                
                await drawImagesFromCategory('adversary_extra_photos_preview_container', 'Photo Supplémentaire - Adversaire');
                await drawImagesFromCategory('renforts_photo_preview_container', 'Photo - Renfort Potentiel');

                addNewPage();
                drawTitle("3. ENVIRONNEMENT");
                drawSubTitle("Ami(e)s (soutien)"); drawWrappedText(getVal('amies'), { size: 14 });
                drawSubTitle("Terrain / Météo"); drawWrappedText(getVal('terrain_info'), { size: 14 });
                drawSubTitle("Population"); drawWrappedText(getVal('population'), { size: 14 });
                drawSubTitle("Cadre juridique"); drawWrappedText(getVal('cadre_juridique'), { size: 14 });
                
                addNewPage();
                drawTitle("4. MISSION");
                drawWrappedText(getVal('missions_psig'), { font: helveticaBoldFont, size: 30, color: context.colors.danger, x: context.margin });
                
                await drawImagesFromCategory('photo_container_transport_pr_preview_container', 'Transport PSIG vers PR');
                await drawImagesFromCategory('photo_container_transport_domicile_preview_container', 'Transport PR vers Domicile');
                await drawImagesFromCategory('photo_container_bapteme_terrain_preview_container', 'Baptême terrain');

                addNewPage();
                drawTitle("5. EXÉUTION");
                const execText = `En vue d'appréhender le mis en cause et empêcher la déperdition des preuves,\nJe veux, le ${getVal('date_execution') || '(date)'} à partir de ${getVal('heure_execution') || '(heure)'}, pour une action ${getVal('type_action') || '(type d\'action)'} investir le domicile\nprésumé de ${getVal('nom_adversaire') || '(nom de l\'adversaire)'} après avoir bouclé celui-ci.`;
                drawWrappedText(execText, { size: 16, x: context.margin });
                drawSubTitle("Chronologie des temps");
                const chronoHeaders = ["Type", "Heure", "Description"];
                const chronoRows = (formData.time_events || []).map(e => [e.type || 'N/A', e.hour || 'N/A', e.description || 'N/A']);
                drawTable(chronoHeaders, chronoRows, [80, 120, 550], context.margin);
                drawSubTitle("Hypothèses");
                const h1 = `H1: ${getVal('hypothese_h1')}`;
                const h2 = `H2: ${getVal('hypothese_h2')}`;
                const h3 = `H3: ${getVal('hypothese_h3')}`;
                drawWrappedText(`${h1}\n${h2}\n${h3}`, { size: 14, font: helveticaBoldFont, color: context.colors.danger });

                addNewPage();
                drawTitle("6. ARTICULATION");
                drawWrappedText(`Place du Chef (Générale): ${getVal('place_chef')}`, { size: 14, x: context.margin });
                drawSubTitle("Équipe INDIA (INTER)"); 
                drawSubTitle("Composition:"); drawCompositionList(getCompositionData('india'));
                drawSubTitle("Mission:"); drawWrappedText(getVal('india_mission'));
                drawSubTitle("Objectif:"); drawWrappedText(getVal('india_objectif')); drawSubTitle("Itinéraire:");
                drawWrappedText(getVal('india_itineraire')); drawSubTitle("Points Particuliers:"); drawWrappedText(getVal('india_points_particuliers'));
                drawSubTitle("Conduite à Tenir:"); drawWrappedText(getVal('india_cat'));
                
                await drawImagesFromCategory('photo_container_itineraire_exterieur_preview_container', 'Itinéraire Extérieur India');
                await drawImagesFromCategory('photo_container_itineraire_interieur_preview_container', 'Itinéraire Intérieur India');
                await drawImagesFromCategory('photo_container_cellule_effraction_preview_container', 'Cellule Effraction');
                
                addNewPage();
                drawTitle("6. ARTICULATION (Suite)");
                drawSubTitle("Équipe Appui/Observation (AO) - ZMSPCP"); 
                drawSubTitle("Composition:"); drawCompositionList(getCompositionData('ao'));
                drawSubTitle("Zone d'installation (Z):");
                drawWrappedText(getVal('ao_zone_installation')); drawSubTitle("Mission (M):"); drawWrappedText(getVal('ao_mission'));
                drawSubTitle("Secteur de surveillance (S):"); drawWrappedText(getVal('ao_secteur_surveillance'));
                drawSubTitle("Points Particuliers (P):"); drawWrappedText(getVal('ao_points_particuliers'));
                drawSubTitle("Place du Chef (P):"); drawWrappedText(getVal('ao_place_chef'));
                drawSubTitle("Conduite à Tenir (C):"); drawWrappedText(getVal('ao_cat'));

                await drawImagesFromCategory('photo_container_emplacement_ao_preview_container', 'Emplacement AO');
                
                addNewPage();
                drawTitle("7. PATRACDVR");
                const patracHeaders = ["Trigramme", "Fonction", "Cellule", "Armement", "Équip. 1", "Équip. 2", "Tenue", "GPB"];
                for (const row of (formData.patracdvr_rows || [])) {
                    if(row.vehicle && row.members && row.members.length > 0) {
                        drawSubTitle(`Véhicule: ${row.vehicle}`);
                        const patracRows = row.members.filter(m => m.trigramme).map(m => [m.trigramme, m.fonction, m.cellule, m.armement, m.equipement, m.equipement2, m.tenue, m.gpb]);
                        if (patracRows.length > 0) { drawTable(patracHeaders, patracRows, [80, 90, 90, 90, 90, 90, 80, 80], context.margin); }
                    }
                }
                
                addNewPage();
                drawTitle("9. Conduites à tenir");
                drawSubTitle("Générales"); drawWrappedText(getVal('cat_generales'), {x: context.margin, font: helveticaBoldFont});
                const noGoText = getVal('no_go');
                if (noGoText) {
                    drawSubTitle("NO GO");
                    drawWrappedText(noGoText, { x: context.margin, font: helveticaBoldFont, size: 14.4, color: context.colors.danger });
                }
                drawSubTitle("Liaison"); drawWrappedText(getVal('cat_liaison'), {x: context.margin, font: helveticaBoldFont});

                const dateOp = getVal('date_op');
                const nomAdversaire = getVal('nom_adversaire');
                if (dateOp && nomAdversaire) {
                    const safeAdversaireName = nomAdversaire.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const oiId = `${dateOp}_${safeAdversaireName}`;
                    const retexUrl = `${RETEX_BASE_URL}?oiId=${encodeURIComponent(oiId)}`;

                    addNewPage();
                    const operationTitle = getVal('nom_adversaire') || 'OPERATION';
                    drawTitle(`RETEX: ${operationTitle.toUpperCase()}`);
                    drawWrappedText("Chaque membre ayant participé à l'opération est tenu de remplir le formulaire de Retour d'Expérience (Retex) en utilisant le lien ci-dessous.", { size: 14, x: context.margin });
                    context.y -= 40;
                    context.currentPage.drawText(retexUrl, { x: context.margin, y: context.y, font: helveticaBoldFont, size: 14, color: context.colors.accent, A: { URI: retexUrl } });
                    context.y -= 20;
                }
                
                addNewPage();
                if (backgroundImage) { context.currentPage.drawImage(backgroundImage, { x: 0, y: 0, width: context.pageWidth, height: context.pageHeight }); }
                const finalText = "Avez vous des questions?";
                const finalTextWidth = helveticaBoldFont.widthOfTextAtSize(finalText, 48);
                context.currentPage.drawText(finalText, { x: context.pageWidth / 2 - finalTextWidth / 2, y: context.pageHeight / 2, font: helveticaBoldFont, size: 48, color: context.colors.accent });
            };

            await pdfCreationLogic();
            const pdfBytes = await pdfDoc.save();
            return { pdfBytes, formData };
        }
        
        // --- PRESENTATION HTML LOGIC ---
        
        async function buildPresentationHtml() {
            saveFormData();
            const formDataString = localStorage.getItem('oiFormData');
            if (!formDataString) { return "<h2>Aucune donnée à présenter.</h2>"; }
            const formData = JSON.parse(formDataString);
            const getVal = (id) => formData[id] || '';
            const isDarkMode = document.body.classList.contains('dark-mode');
            
            const accentColor = isDarkMode ? '#5b9bd5' : '#0033a0';
            const primaryText = isDarkMode ? '#e0e0e0' : '#212529';
            const secondaryText = isDarkMode ? '#95a5a6' : '#6c757d';
            const dangerColor = '#c0392b';

            let htmlContent = `<div style="font-family: 'Oswald', sans-serif; color: ${primaryText};">`;

            const cleanText = (text) => String(text || '').replace(/\*\*(.*?)\*\*/g, '$1').trim();
            
            const wrapHtml = (text, tag = 'p', style = {}) => {
                const styleString = Object.entries(style).map(([key, value]) => `${key}:${value}`).join(';');
                const formattedText = String(text || '')
                    .replace(/\*\*/g, '') 
                    .replace(/\n/g, '<br>');
                return `<${tag} style="${styleString}">${formattedText}</${tag}>`;
            };

            const drawTitleHtml = (text) => wrapHtml(cleanText(text), 'h2', { 'color': accentColor, 'font-size': '1.8em', 'margin-top': '20px', 'padding-bottom': '5px', 'border-bottom': `2px solid ${accentColor}` });
            const drawSubTitleHtml = (text) => wrapHtml(cleanText(text), 'h3', { 'color': accentColor, 'font-size': '1.3em', 'margin-top': '15px', 'margin-bottom': '10px' });
            const drawTextHtml = (text, bold = false, color = primaryText, size = '1.1em', indent = '15px') => wrapHtml(text, 'p', { 'font-weight': bold ? '500' : '400', 'color': color, 'font-size': size, 'margin-bottom': '8px', 'padding-left': indent, 'white-space': 'pre-wrap' });
            
            const drawTableHtml = (headers, rows) => {
                let table = `<table style="width: 100%; border-collapse: collapse; margin-top: 15px; margin-bottom: 20px;">`;
                table += `<thead style="background-color: ${accentColor}; color: white;"><tr>`;
                headers.forEach(h => { table += `<th style="padding: 10px; border: 1px solid ${primaryText}; text-align: left;">${h}</th>`; });
                table += `</tr></thead><tbody>`;
                rows.forEach(row => {
                    table += `<tr style="background-color: ${isDarkMode ? '#2a2a2a' : '#f8f9fa'};">`;
                    row.forEach(cell => { 
                        const cellContent = String(cell || '').replace(/\*\*/g, '').replace(/\n/g, '<br>');
                        table += `<td style="padding: 10px; border: 1px solid ${secondaryText}; vertical-align: top;">${cellContent}</td>`; 
                    });
                    table += `</tr>`;
                });
                table += `</tbody></table>`;
                return table;
            };

            const drawImagesHtmlFromCategory = async (previewContainerId, title) => {
                let imageHtml = '';
                const imagesData = (formData.dynamic_photos || {})[previewContainerId] || [];

                for (let i = 0; i < imagesData.length; i++) {
                    const imgData = imagesData[i];
                    const annotations = JSON.parse(imgData.annotations || '[]');
                    const imageBlob = await dbManager.getImage(imgData.id);
            
                    if (!imageBlob) continue;
            
                    let finalImageBlob = imageBlob;
                    if (annotations.length > 0) {
                        try {
                            finalImageBlob = await createAnnotatedImageBlob(imageBlob, annotations);
                        } catch (e) {
                            console.error(`Erreur de génération d'image annotée pour ${title} (index ${i}):`, e);
                        }
                    }
                    
                    const objectURL = URL.createObjectURL(finalImageBlob);
            
                    const finalTitle = imagesData.length > 1 ? `${title} (${i+1})` : title;
                    imageHtml += `<div class="image-container" style="text-align: center; margin: 20px 0; border: 1px solid ${accentColor}; padding: 10px; background-color: ${isDarkMode ? '#1e1e1e' : '#ffffff'};">`;
                    imageHtml += `<h4 style="color: ${accentColor}; margin-bottom: 10px; font-size: 1.1em;">${finalTitle}</h4>`;
                    imageHtml += `<img src="${objectURL}" alt="${finalTitle}" style="max-width: 100%; height: auto; border-radius: 4px; box-shadow: 0 4px 8px rgba(0,0,0,${isDarkMode ? 0.4 : 0.1});" onload="URL.revokeObjectURL(this.src)">`;
                    imageHtml += `</div>`;
                }
                return imageHtml;
            };
            
            const getCompositionHtml = (teamPrefix) => {
                const membersByCell = {};
                const allMembers = (formData.patracdvr_rows || []).flatMap(row => row.members);
                
                allMembers.forEach(member => {
                    if (member.cellule && member.cellule.toLowerCase().startsWith(teamPrefix)) {
                        if (!membersByCell[member.cellule]) membersByCell[member.cellule] = [];
                        member.trigramme && membersByCell[member.cellule].push(
                            `<span style="color: ${primaryText};">${member.trigramme}</span>` + 
                            (member.fonction && member.fonction !== 'Sans' ? ` (${member.fonction})` : '')
                        );
                    }
                });

                const naturalSort = (a, b) => a.localeCompare(b, undefined, { numeric: true, sensitivity: 'base' });
                const sortedKeys = Object.keys(membersByCell).sort(naturalSort);
                
                let compositionHtml = '<div style="padding-left: 15px; margin-bottom: 15px;">';
                sortedKeys.forEach(cell => {
                    compositionHtml += `<p style="margin-bottom: 5px;"><strong style="color: ${dangerColor}; font-size: 1.1em;">${cell.toUpperCase()}</strong> : ${membersByCell[cell].join(', ')}</p>`;
                });
                compositionHtml += '</div>';
                return sortedKeys.length > 0 ? compositionHtml : drawTextHtml('Aucun membre assigné.', false, secondaryText);
            };
            
            
            htmlContent += drawTitleHtml(`Ordre Initial - ${getVal('nom_adversaire') || 'OPÉRATION'}`);
            htmlContent += drawTextHtml(`Date de l'opération : ${getVal('date_op') || 'N/A'}`, true, primaryText, '1.2em', '0');
            htmlContent += drawTitleHtml("1. SITUATION");
            htmlContent += drawSubTitleHtml("1.1 Situation Générale"); htmlContent += drawTextHtml(getVal('situation_generale'));
            htmlContent += drawSubTitleHtml("1.2 Situation Particulière"); htmlContent += drawTextHtml(getVal('situation_particuliere'));

            htmlContent += drawTitleHtml("2. ADVERSAIRE");
            htmlContent += await drawImagesHtmlFromCategory('adversary_photo_preview_container', "Photo de l'objectif"); 

            const meText = (formData.me_list || []).map((me, i) => `ME${i+1}: ${me}`).join(' | ');
            const adversaireRows = [
                ['Nom/Prénom', getVal('nom_adversaire')], ['Domicile', getVal('domicile_adversaire')],
                ['Naissance', `${getVal('date_naissance')} à ${getVal('lieu_naissance')}`],
                ['Description', `${getVal('stature_adversaire')} / ${getVal('ethnie_adversaire')}`],
                ['Signes particuliers', getVal('signes_particuliers')], ['Profession', getVal('profession_adversaire')],
                ['Antécédents', getVal('antecedents_adversaire')], ['État d\'esprit', (formData.etat_esprit_list || []).join(', ')],
                ['Attitude (connue)', getVal('attitude_adversaire')], ['Volume (renfort)', (formData.volume_list || []).join(', ')],
                ['Substances', getVal('substances_adversaire')], ['Véhicules', (formData.vehicules_list || []).join(', ')],
                ['Armes connues', getVal('armes_connues')], ['Moyens Employés', meText],
            ].filter(row => row[1] && String(row[1]).trim() !== 'à');

            if (adversaireRows.length > 0) {
                htmlContent += drawTableHtml(["Information", "Détail"], adversaireRows);
            } else {
                 htmlContent += drawTextHtml("Aucune information détaillée sur l'adversaire.");
            }

            htmlContent += await drawImagesHtmlFromCategory('adversary_extra_photos_preview_container', 'Photo Supplémentaire - Adversaire');
            htmlContent += await drawImagesHtmlFromCategory('renforts_photo_preview_container', 'Photo - Renfort Potentiel');

            htmlContent += drawTitleHtml("3. ENVIRONNEMENT");
            htmlContent += drawSubTitleHtml("Ami(e)s (soutien)"); htmlContent += drawTextHtml(getVal('amies'));
            htmlContent += drawSubTitleHtml("Terrain / Météo"); htmlContent += drawTextHtml(getVal('terrain_info'));
            htmlContent += drawSubTitleHtml("Population"); htmlContent += drawTextHtml(getVal('population'));
            htmlContent += drawSubTitleHtml("Cadre juridique"); htmlContent += drawTextHtml(getVal('cadre_juridique'));

            htmlContent += drawTitleHtml("4. MISSION DU PSIG");
            htmlContent += drawTextHtml(getVal('missions_psig'), true, dangerColor, '1.6em', '0');
            
            htmlContent += drawTitleHtml("5. EXÉCUTION");
            const execText = `En vue d'appréhender le mis en cause et empêcher la déperdition des preuves,<br>Je veux, le ${getVal('date_execution') || '(date)'} à partir de ${getVal('heure_execution') || '(heure)'}, pour une action ${getVal('type_action') || '(type d\'action)'} investir le domicile<br>présumé de ${getVal('nom_adversaire') || '(nom de l\'adversaire)'} après avoir bouclé celui-ci.`;
            htmlContent += wrapHtml(execText, 'p', { 'font-size': '1.4em', 'margin-bottom': '15px', 'padding-left': '0' });

            htmlContent += drawSubTitleHtml("Chronologie des temps");
            const chronoHeaders = ["Type", "Heure", "Description"];
            const chronoRows = (formData.time_events || []).map(e => [e.type || 'N/A', e.hour || 'N/A', e.description || 'N/A']);
            htmlContent += drawTableHtml(chronoHeaders, chronoRows);

            htmlContent += drawSubTitleHtml("Hypothèses");
            htmlContent += drawTextHtml(`<span style="color: ${dangerColor}; font-weight: bold;">H1</span>: ${getVal('hypothese_h1')}<br><span style="color: ${dangerColor}; font-weight: bold;">H2</span>: ${getVal('hypothese_h2')}<br><span style="color: ${dangerColor}; font-weight: bold;">H3</span>: ${getVal('hypothese_h3')}`, true, primaryText, '1.2em');
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_transport_pr_preview_container', 'Transport PSIG vers PR');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_transport_domicile_preview_container', 'Transport PR vers Domicile');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_bapteme_terrain_preview_container', 'Baptême terrain');

            htmlContent += drawTitleHtml("6. ARTICULATION (MOIPC/ZMSPCP)");
            htmlContent += drawTextHtml(`Place du Chef (Générale): ${getVal('place_chef')}`, true, primaryText, '1.2em', '0');

            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe INDIA (INTER)</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px', 'font-size': '1.1em' });
            htmlContent += getCompositionHtml('india');
            const moipcText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('india_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">O</span>bjectif : ${getVal('india_objectif')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">I</span>tinéraire : ${getVal('india_itineraire')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('india_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('india_cat')}
            </p>`;
            htmlContent += moipcText;
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_itineraire_exterieur_preview_container', 'Itinéraire Extérieur India');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_itineraire_interieur_preview_container', 'Itinéraire Intérieur India');
            htmlContent += await drawImagesHtmlFromCategory('photo_container_cellule_effraction_preview_container', 'Cellule Effraction');

            htmlContent += drawTitleHtml("6. ARTICULATION (Suite)");
            htmlContent += drawSubTitleHtml(`<span style="color: ${accentColor}; font-weight: bold;">Équipe Appui/Observation (AO) - ZMSPCP</span>`);
            htmlContent += wrapHtml('<strong style="color: ' + accentColor + ';">Composition:</strong>', 'h4', { 'padding-left': '15px', 'margin-top': '10px', 'font-size': '1.1em' });
            htmlContent += getCompositionHtml('ao');
            
            const aoText = `<p style="padding-left:15px; margin-bottom: 8px;">
                <span style="color: ${dangerColor}; font-weight: bold;">Z</span>one d'installation : ${getVal('ao_zone_installation')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">M</span>ission : ${getVal('ao_mission')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">S</span>ecteur de surveillance : ${getVal('ao_secteur_surveillance')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>oints Particuliers : ${getVal('ao_points_particuliers')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">C</span>onduite à Tenir : ${getVal('ao_cat')}<br>
                <span style="color: ${dangerColor}; font-weight: bold;">P</span>lace du Chef : ${getVal('ao_place_chef')}
            </p>`;
            htmlContent += aoText;
            
            htmlContent += await drawImagesHtmlFromCategory('photo_container_emplacement_ao_preview_container', 'Emplacement AO');

            htmlContent += drawTitleHtml("7. PATRACDVR (Détail de la Composition)");
            const patracHeaders = ["Trigramme", "Fonction", "Cellule", "Armement", "Équip. 1", "Équip. 2", "Tenue", "GPB"];
            for (const row of (formData.patracdvr_rows || [])) {
                if(row.vehicle && row.members && row.members.length > 0) {
                    htmlContent += drawSubTitleHtml(`Véhicule: ${row.vehicle}`);
                    const patracRows = row.members.filter(m => m.trigramme).map(m => [m.trigramme, m.fonction, m.cellule, m.armement, m.equipement, m.equipement2, m.tenue, m.gpb]);
                    if (patracRows.length > 0) { htmlContent += drawTableHtml(patracHeaders, patracRows); }
                }
            }
            
            htmlContent += drawTitleHtml("9. CONDUITES À TENIR");
            htmlContent += drawSubTitleHtml("Générales"); htmlContent += drawTextHtml(getVal('cat_generales'), true);
            const noGoText = getVal('no_go');
            if (noGoText) {
                htmlContent += drawSubTitleHtml("NO GO");
                htmlContent += drawTextHtml(noGoText, true, dangerColor, '1.2em');
            }
            htmlContent += drawSubTitleHtml("Liaison"); htmlContent += drawTextHtml(getVal('cat_liaison'), true);
            
            const dateOp = getVal('date_op');
            const nomAdversaire = getVal('nom_adversaire');
            if (dateOp && nomAdversaire) {
                const safeAdversaireName = nomAdversaire.trim().replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const oiId = `${dateOp}_${safeAdversaireName}`;
                const retexUrl = `${RETEX_BASE_URL}?oiId=${encodeURIComponent(oiId)}`;
                htmlContent += drawTitleHtml("LIEN RETEX");
                htmlContent += drawTextHtml("Lien d'accès au formulaire de Retour d'Expérience:", false);
                htmlContent += wrapHtml(`<a href="${retexUrl}" target="_blank" style="color: ${accentColor}; font-weight: bold; font-size: 1.1em; text-decoration: none;">${retexUrl}</a>`, 'p', { 'padding-left': '15px' });
            }

            htmlContent += `</div>`;
            return htmlContent;
        }
    </script>
</body>
</html>
